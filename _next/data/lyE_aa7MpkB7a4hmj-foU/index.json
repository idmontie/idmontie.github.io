{"pageProps":{"posts":[{"slug":"2023-09-24-impostor-syndrome","date":"2023-09-24","title":"In Good Company, Impostor Syndrome","frontmatter":{"title":"In Good Company, Impostor Syndrome"},"contentRaw":"\nWe’ve all felt it at some point in our careers: that dreaded feeling of impostor syndrome kicking in as we find ourselves in over our heads. Questions like, “Am I truly qualified for this?” and “Are my peers facing the same challenges?” often plague our minds.\n\nImpostor syndrome is such a universal experience that countless articles, conference talks, and books have been dedicated to the topic.\n\nBut is this just a human emotion? I think impostor syndrome also applies to startups and companies as well. While a lot less universal, some of us in the tech world have had the misfortune of working at such impostor syndrome companies. And that anxiety manifests itself into doubt in the employees, bringing everyone down.\n\n> For example, many startups use Jira because large companies use Jira.\n>\n> - https://blog.johnqian.com/startup-spark\n\nWhether or not you like JIRA, the startup impostor syndrome manifests itself in similar ways: pick safe tech that larger companies use. It must be good because the larger company we think is successful uses it. Emulate success and surely we will be successful.\n\nOr it may show up in processes. A manager comes into a startup from a large successful company and blindly imposes large corporate processes to the small company. Everything slows down, dampening the enthusiasm of the team. Emulate the processes of a large company and surely we will be successful.\n\nThis mindset isn't new. The old adage “[No one has ever been fired for buying IBM](https://www.origina.com/blog/nobody-ever-got-fired-for-buying-ibm)” highlights the tendency to play it safe in the face of doubt. When we have doubt, even as a company, we like to play it safe; but, innovation and large payoffs don't happen from playing it safe. They come from risk and opportunity.\n\nWhen we play it too safe, too cautiously, we are giving into that impostor syndrome and settling for good enough. In our personal lives and I'm business, emulating success is usually just a facade for fear of risk. It's difficult to go out there and create new processes when you are so used to an old process you learned at a larger company. It's difficult to go out there and pick a technology that no one is using compared to one that a large company is using. And it's difficult to go out there and solve problems you think are over your head.\n\nThat feeling of impostor syndrome is good. It means you are pushing your limits and getting out of your comfort zone. You are tackling problems you haven't experienced before. And if you don't just try to emulate others, you might make mistakes, but they are your learning opportunities for growth. Then you can look back and see how far you've come, not by playing it safe and fearing impostor syndrome, but by embracing it.","contentHTML":"<p>We’ve all felt it at some point in our careers: that dreaded feeling of impostor syndrome kicking in as we find ourselves in over our heads. Questions like, “Am I truly qualified for this?” and “Are my peers facing the same challenges?” often plague our minds.</p>\n<p>Impostor syndrome is such a universal experience that countless articles, conference talks, and books have been dedicated to the topic.</p>\n<p>But is this just a human emotion? I think impostor syndrome also applies to startups and companies as well. While a lot less universal, some of us in the tech world have had the misfortune of working at such impostor syndrome companies. And that anxiety manifests itself into doubt in the employees, bringing everyone down.</p>\n<blockquote class=\"border-l-4 border-gray-300 pl-4\">\n<p>For example, many startups use Jira because large companies use Jira.</p>\n<ul>\n<li><a href=\"https://blog.johnqian.com/startup-spark\">https://blog.johnqian.com/startup-spark</a></li>\n</ul>\n</blockquote>\n<p>Whether or not you like JIRA, the startup impostor syndrome manifests itself in similar ways: pick safe tech that larger companies use. It must be good because the larger company we think is successful uses it. Emulate success and surely we will be successful.</p>\n<p>Or it may show up in processes. A manager comes into a startup from a large successful company and blindly imposes large corporate processes to the small company. Everything slows down, dampening the enthusiasm of the team. Emulate the processes of a large company and surely we will be successful.</p>\n<p>This mindset isn&#x27;t new. The old adage “<a href=\"https://www.origina.com/blog/nobody-ever-got-fired-for-buying-ibm\">No one has ever been fired for buying IBM</a>” highlights the tendency to play it safe in the face of doubt. When we have doubt, even as a company, we like to play it safe; but, innovation and large payoffs don&#x27;t happen from playing it safe. They come from risk and opportunity.</p>\n<p>When we play it too safe, too cautiously, we are giving into that impostor syndrome and settling for good enough. In our personal lives and I&#x27;m business, emulating success is usually just a facade for fear of risk. It&#x27;s difficult to go out there and create new processes when you are so used to an old process you learned at a larger company. It&#x27;s difficult to go out there and pick a technology that no one is using compared to one that a large company is using. And it&#x27;s difficult to go out there and solve problems you think are over your head.</p>\n<p>That feeling of impostor syndrome is good. It means you are pushing your limits and getting out of your comfort zone. You are tackling problems you haven&#x27;t experienced before. And if you don&#x27;t just try to emulate others, you might make mistakes, but they are your learning opportunities for growth. Then you can look back and see how far you&#x27;ve come, not by playing it safe and fearing impostor syndrome, but by embracing it.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"We’ve all felt it at some point in our careers: that dreaded feeling of impostor syndrome kicking in as we find ourselves in over our heads. Questions like, “Am I truly qualified for this?” and “Are my peers facing the same challenges?” often plague our minds.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Impostor syndrome is such a universal experience that countless articles, conference talks, and books have been dedicated to the topic.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But is this just a human emotion? I think impostor syndrome also applies to startups and companies as well. While a lot less universal, some of us in the tech world have had the misfortune of working at such impostor syndrome companies. And that anxiety manifests itself into doubt in the employees, bringing everyone down.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"For example, many startups use Jira because large companies use Jira.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://blog.johnqian.com/startup-spark\",\n            children: \"https://blog.johnqian.com/startup-spark\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Whether or not you like JIRA, the startup impostor syndrome manifests itself in similar ways: pick safe tech that larger companies use. It must be good because the larger company we think is successful uses it. Emulate success and surely we will be successful.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Or it may show up in processes. A manager comes into a startup from a large successful company and blindly imposes large corporate processes to the small company. Everything slows down, dampening the enthusiasm of the team. Emulate the processes of a large company and surely we will be successful.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This mindset isn't new. The old adage “\", _jsx(_components.a, {\n        href: \"https://www.origina.com/blog/nobody-ever-got-fired-for-buying-ibm\",\n        children: \"No one has ever been fired for buying IBM\"\n      }), \"” highlights the tendency to play it safe in the face of doubt. When we have doubt, even as a company, we like to play it safe; but, innovation and large payoffs don't happen from playing it safe. They come from risk and opportunity.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When we play it too safe, too cautiously, we are giving into that impostor syndrome and settling for good enough. In our personal lives and I'm business, emulating success is usually just a facade for fear of risk. It's difficult to go out there and create new processes when you are so used to an old process you learned at a larger company. It's difficult to go out there and pick a technology that no one is using compared to one that a large company is using. And it's difficult to go out there and solve problems you think are over your head.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That feeling of impostor syndrome is good. It means you are pushing your limits and getting out of your comfort zone. You are tackling problems you haven't experienced before. And if you don't just try to emulate others, you might make mistakes, but they are your learning opportunities for growth. Then you can look back and see how far you've come, not by playing it safe and fearing impostor syndrome, but by embracing it.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWe’ve all felt it at some point in our careers: that dreaded feeling of impostor syndrome kicking in as we find ourselves in over our heads. Questions like, “Am I truly qualified for this?” and “Are my peers facing the same challenges?” often plague our minds.","excerptHTML":"<p>We’ve all felt it at some point in our careers: that dreaded feeling of impostor syndrome kicking in as we find ourselves in over our heads. Questions like, “Am I truly qualified for this?” and “Are my peers facing the same challenges?” often plague our minds.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"We’ve all felt it at some point in our careers: that dreaded feeling of impostor syndrome kicking in as we find ourselves in over our heads. Questions like, “Am I truly qualified for this?” and “Are my peers facing the same challenges?” often plague our minds.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]},{"slug":"2023-08-19-localization","date":"2023-08-19","title":"Enforcing Localization through Types","frontmatter":{"title":"Enforcing Localization through Types","tags":["typescript","react"]},"contentRaw":"\nWhen building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?\n\n## Defining a Localized Type\n\nTypescript doesn’t natively provide an [Opaque type](https://en.wikipedia.org/wiki/Opaque_data_type) that we can use to define a string that has already been localized. If the data looks like a string, Typescript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in [type-fest](https://github.com/sindresorhus/type-fest):\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA)\n\nHere is a short example where we create a localized string and try to use a raw string and our localized string in a function:\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example('test')); // Will throw a type error\nconsole.log(example(createLocalizedString('test'))); // Works correctly\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA)\n\nNow we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\n\n## Enforcing in Components\n\nThe simplest way we can enforce that strings have already been localized is by using the type in our component’s props interface:\n\n```tsx\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n```\n\nNow if we try to use that component without a localized string, we get an error:\n\n```tsx\nimport React from 'react';\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction Example() {\n    return (\n        <>\n            <Button label=\"Test\" />\n            <Button label={createLocalizedString(\"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA)\n\n## Localizing Strings\n\nSo far, we’ve been using a utility `createLocalizedString` to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we’ll want to use a translation function from [react-i18next](https://github.com/i18next/react-i18next) or [next-i18next](https://github.com/i18next/next-i18next) to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\n\n```tsx\nimport React, { useCallback } from 'react';\nimport { Opaque } from 'type-fest';\nimport { useTranslation } from 'react-i18next';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) => {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        <>\n            <Button label={t(\"test\", \"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA)\n\nHere we use `useTranslation` from `react-i18next` and wrap the `t` translation function that is returned to override the type it gives us.\n\nNow when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\n","contentHTML":"<p>When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?</p>\n<h2>Defining a Localized Type</h2>\n<p>Typescript doesn’t natively provide an <a href=\"https://en.wikipedia.org/wiki/Opaque_data_type\">Opaque type</a> that we can use to define a string that has already been localized. If the data looks like a string, Typescript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in <a href=\"https://github.com/sindresorhus/type-fest\">type-fest</a>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\">Playground example</a></p>\n<p>Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example(&#x27;test&#x27;)); // Will throw a type error\nconsole.log(example(createLocalizedString(&#x27;test&#x27;))); // Works correctly\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\">Playground example</a></p>\n<p>Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.</p>\n<h2>Enforcing in Components</h2>\n<p>The simplest way we can enforce that strings have already been localized is by using the type in our component’s props interface:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n</code></pre></div>\n<p>Now if we try to use that component without a localized string, we get an error:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import React from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction Example() {\n    return (\n        &lt;&gt;\n            &lt;Button label=&quot;Test&quot; /&gt;\n            &lt;Button label={createLocalizedString(&quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\">Playground example</a></p>\n<h2>Localizing Strings</h2>\n<p>So far, we’ve been using a utility <code>createLocalizedString</code> to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we’ll want to use a translation function from <a href=\"https://github.com/i18next/react-i18next\">react-i18next</a> or <a href=\"https://github.com/i18next/next-i18next\">next-i18next</a> to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import React, { useCallback } from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\nimport { useTranslation } from &#x27;react-i18next&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) =&gt; {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        &lt;&gt;\n            &lt;Button label={t(&quot;test&quot;, &quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\">Playground example</a></p>\n<p>Here we use <code>useTranslation</code> from <code>react-i18next</code> and wrap the <code>t</code> translation function that is returned to override the type it gives us.</p>\n<p>Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Defining a Localized Type\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Typescript doesn’t natively provide an \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Opaque_data_type\",\n        children: \"Opaque type\"\n      }), \" that we can use to define a string that has already been localized. If the data looks like a string, Typescript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in \", _jsx(_components.a, {\n        href: \"https://github.com/sindresorhus/type-fest\",\n        children: \"type-fest\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\nfunction example(s: LocalizedString) {\\n    return s;\\n}\\n\\nconsole.log(example('test')); // Will throw a type error\\nconsole.log(example(createLocalizedString('test'))); // Works correctly\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Enforcing in Components\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The simplest way we can enforce that strings have already been localized is by using the type in our component’s props interface:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now if we try to use that component without a localized string, we get an error:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React from 'react';\\nimport { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction Example() {\\n    return (\\n        <>\\n            <Button label=\\\"Test\\\" />\\n            <Button label={createLocalizedString(\\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Localizing Strings\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So far, we’ve been using a utility \", _jsx(_components.code, {\n        children: \"createLocalizedString\"\n      }), \" to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we’ll want to use a translation function from \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/react-i18next\",\n        children: \"react-i18next\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/next-i18next\",\n        children: \"next-i18next\"\n      }), \" to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React, { useCallback } from 'react';\\nimport { Opaque } from 'type-fest';\\nimport { useTranslation } from 'react-i18next';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction useLocalizedTranslation() {\\n    const { t : originalTranslate } = useTranslation();\\n\\n    const t = useCallback((key: string, defaultString: string) => {\\n        return originalTranslate(key, defaultString) as LocalizedString;\\n    }, [originalTranslate]);\\n\\n    return { t };\\n}\\n\\nfunction Example() {\\n    const { t } = useLocalizedTranslation();\\n    return (\\n        <>\\n            <Button label={t(\\\"test\\\", \\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we use \", _jsx(_components.code, {\n        children: \"useTranslation\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"react-i18next\"\n      }), \" and wrap the \", _jsx(_components.code, {\n        children: \"t\"\n      }), \" translation function that is returned to override the type it gives us.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?","excerptHTML":"<p>When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript","react"]}],"projects":[{"slug":"2023-09-10-wax-book","date":"2023-09-10","title":"Interactive Smart Contracts on WAX","frontmatter":{"title":"Interactive Smart Contracts on WAX","image":"/images/project-wax-book.png","description":"My e-book on WAX Smart Contract development that guides developers through the process of creating a non-fungible token (NFT) smart contract.\n","language_tags":["node","cpp"],"framework_tags":["wax","blockchain","nfts"],"view_link":"https://amzn.to/463p6TX"},"contentRaw":"\nDive into the dynamic world of the WAX blockchain with this comprehensive tutorial series. From creating unique non-fungible tokens (NFTs) using AtomicAssets and crafting simple \"Hello World\" contracts, to deploying intricate guestbook contracts both locally and on the testnet, these tutorials provide a step-by-step guide to harnessing the full potential of WAX. Whether you're a developer eager to explore decentralized applications or an enthusiast curious about digital assets, this series offers invaluable insights into the robust capabilities of the WAX platform.","contentHTML":"<p>Dive into the dynamic world of the WAX blockchain with this comprehensive tutorial series. From creating unique non-fungible tokens (NFTs) using AtomicAssets and crafting simple &quot;Hello World&quot; contracts, to deploying intricate guestbook contracts both locally and on the testnet, these tutorials provide a step-by-step guide to harnessing the full potential of WAX. Whether you&#x27;re a developer eager to explore decentralized applications or an enthusiast curious about digital assets, this series offers invaluable insights into the robust capabilities of the WAX platform.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"Dive into the dynamic world of the WAX blockchain with this comprehensive tutorial series. From creating unique non-fungible tokens (NFTs) using AtomicAssets and crafting simple \\\"Hello World\\\" contracts, to deploying intricate guestbook contracts both locally and on the testnet, these tutorials provide a step-by-step guide to harnessing the full potential of WAX. Whether you're a developer eager to explore decentralized applications or an enthusiast curious about digital assets, this series offers invaluable insights into the robust capabilities of the WAX platform.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nDive into the dynamic world of the WAX blockchain with this comprehensive tutorial series. From creating unique non-fungible tokens (NFTs) using AtomicAssets and crafting simple \"Hello World\" contracts, to deploying intricate guestbook contracts both locally and on the testnet, these tutorials provide a step-by-step guide to harnessing the full potential of WAX. Whether you're a developer eager to explore decentralized applications or an enthusiast curious about digital assets, this series offers invaluable insights into the robust capabilities of the WAX platform.","excerptHTML":"<p>Dive into the dynamic world of the WAX blockchain with this comprehensive tutorial series. From creating unique non-fungible tokens (NFTs) using AtomicAssets and crafting simple &quot;Hello World&quot; contracts, to deploying intricate guestbook contracts both locally and on the testnet, these tutorials provide a step-by-step guide to harnessing the full potential of WAX. Whether you&#x27;re a developer eager to explore decentralized applications or an enthusiast curious about digital assets, this series offers invaluable insights into the robust capabilities of the WAX platform.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"Dive into the dynamic world of the WAX blockchain with this comprehensive tutorial series. From creating unique non-fungible tokens (NFTs) using AtomicAssets and crafting simple \\\"Hello World\\\" contracts, to deploying intricate guestbook contracts both locally and on the testnet, these tutorials provide a step-by-step guide to harnessing the full potential of WAX. Whether you're a developer eager to explore decentralized applications or an enthusiast curious about digital assets, this series offers invaluable insights into the robust capabilities of the WAX platform.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]},{"slug":"2023-08-07-wax-cpp-tutorial","date":"2023-08-07","title":"WAX C++ NFT Tutorial","frontmatter":{"title":"WAX C++ NFT Tutorial","image":"/images/project-wax.jpg","description":"WAX smart contract development course that guides developers through the process of creating a non-fungible token (NFT) smart contract.\n","language_tags":["node","cpp"],"framework_tags":["wax","blockchain","nfts"],"view_link":"https://dev.to/idmontie/series/23860","github_link":"https://github.com/CapsuleCat/wax-nft-tutorial"},"contentRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\n\nIt is a great introduction to WAX smart contract development and the WAX ecosystem.\n","contentHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.</p>\n<p>It is a great introduction to WAX smart contract development and the WAX ecosystem.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"This is a 22 part series on DevTo that goes through the entire process of creating\\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is a great introduction to WAX smart contract development and the WAX ecosystem.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating","excerptHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"This is a 22 part series on DevTo that goes through the entire process of creating\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]}]},"__N_SSG":true}