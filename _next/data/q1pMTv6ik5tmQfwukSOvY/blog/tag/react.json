{"pageProps":{"headTitle":"react posts - idmontie's Portfolio","headKeywords":"react","tag":"react","posts":[{"slug":"2025-12-07-spreading-type-holes","date":"2025-12-07","title":"Forbidden Typescript: Spreading Type-holes","frontmatter":{"title":"Forbidden Typescript: Spreading Type-holes","tags":["technology","programming","react","typescript"]},"contentRaw":"\nI've discussed [full and partial objects before on this blog](/blog/post/2023-08-14-partial-objects), and in this article I'm going to investigate a common factory pattern\nin Typescript that can lead to type-holes.\nWhen writing tests or complex components, I'll often create prop factory utilities.\n\n<!--truncate-->\n\nFor tests, the goal is to create props with all the default values, except a few that may be\noveridden for a specific test case. The function signature typically looks like this:\n\n```jsx\nfunction makeFoo(partial?: Partial<Foo>): Foo;\n```\n\nThe expectation is that a software developer can call `makeFoo` and get a version of `Foo` that has all the defaults set to use in tests. Then, if the developer want to override a few fields to test an edge case, all they do is call `makeFoo({ fieldA: 'special-case })`.\n\nI’ve seen developers try to implement this a few ways, each with its pros and cons.\n\n### Spreading\n\nThe easiest way to implement this function is to just provide defaults and spread the partial:\n\n```jsx\ninterface Foo {\n  fieldA: string;\n  fieldB?: string;\n  fieldC?: boolean | null;\n}\n\nfunction makeFoo(partial?: Partial<Foo>): Foo {\n  return {\n\t  fieldA: 'test',\n    fieldB: 'example',\n    fieldC: false,\n    ...partial\n  };\n}\n```\n\nHere, we create a `Foo`  mock with overrides for the defaults, which are provided by `partial?: Partial<Foo>` . However, even though `fieldA` is required, we can see a type-hole with the default Typescript compilation settings:\n\n```jsx\nconst instance = makeFoo({ fieldA: undefined, fieldB: undefined, fieldC: undefined });\nconsole.log(instance.fieldA);\n\n// No type error, but this blows up\nconsole.log(instance.fieldA.toLowerCase());\n```\n\nWhen we spread, `undefined` actually overrides the default! But why were we allowed to provide `undefined` in the first place?\n\nIn Typescript, `Partial<Foo>`  keeps all the fields, but makes them optional. In the default compilation settings, an optional field can be set to `undefined`.\n\n[Typescript Playground Link](https://www.typescriptlang.org/play/?#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTIAOSQ9BkANOwpnGRcNBkQAB5wFk7yeQUcYuI08CS0EPkEBAB0PS5uwB7sOrr6COb0yKD0ikjIALzIVrb2DtgNaTRGZBBEIBBkyDohbGMgtOjyXSToTA5TYDMQXamUx-oA9O-IAHJYYACeThQ0Cg6CguRk6jAyDAAAtgLQZNcAO6I9ROXCnc6Xa63e6PZ5FChdMDoAAy6GR0HEcDaDhCxyAA)\n\nThere is a Typescript compilation flag to throw a type-error and keep our sanity: `exactOptionalPropertyTypes`. Enabling this flag makes Typescript show an error for `makeFoo({ fieldA: undefined, fieldB: undefined, fieldC: undefined });`. We can add the field to the call if it is set to a value.\n\n[Typescript Playground Link](https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTIAOSQ9BkANOwpnGRcNBkQAB5wFk7yeQUcYuI08CS0EPkEBAB0PS5uwB7sOrr6COb0yKD0ikjIALzIVrb2DtgNaTRGZBBEIBBkuevFmyDbu-uHqRInZ6D7yDohbGMgtOjyXSToTA5TYDMQLpXChPUbjd6Ar4-P4AoFFChdMDoAAy6AA7tBxHA2g4Qk8gA)\n\nBut this causes another problem: it is perfectly valid to create an initial instance of `Foo` without fieldB being set (and its value being `undefined`). But now our `makeFoo` object doesn’t allow us to pass `fieldB: undefined` anymore. Only when the interface explicitly defines fieldB as optional AND undefined does it allow us to so.\n\n[Typescript Playground Link](https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQTZAB9kAVxBkIREBDJsCRUmQDCfZACNMJCHBCjkIcSRJsAvrlwxJCMMHQGAtnADWEDOgAUABzhR7OBINAAV-QJIAHk8APgBKGk8cdigIMHEoAzwASCVOShoAckh6QoAadjyVLiKIAA84Jx9dcsqOFVUaeBJaCAqCAgA6Yb8A4CD2cwsrBEd6ZFB6fSRkAF5kF3dPL2x27hpJaVl5ZHM4tlmQWnRdQZJ0Ji9FsGWIQeVyCnOZuZu3+8ez1e73yFEGYHQABl0AB3aCqOC9Lxxc5AA)\n\nGenerally this pattern without the flag is fine for creating mock data, since any type-holes would only be scoped to tests and not real production code. But the question is: can we have `makeFoo` take a partial, return Foo without type-holes, and have allow `undefined` for partials?\n\n## Null-Coalescing Every Field\n\nAnother common implementation I have seen is to add nullish coalescing to every field:\n\n```jsx\ninterface Foo {\n  fieldA: string;\n  fieldB?: string;\n  fieldC?: boolean | null;\n}\n\nfunction makeFoo(partial?: Partial<Foo>): Foo {\n  return {\n\t  fieldA: partial?.fieldA ?? 'test',\n    fieldB: partial?.fieldB ?? 'example',\n    fieldC: partial?.fieldC ?? false,\n  };\n} \n```\n\nLet’s also turn off the `exactOptionalPropertyTypes` compilation flag for now.\n\nWe know every field will be set correctly, so there are no type-holes in `Foo`, however, we still have the problem where we cannot override a field to the `unset` value of `undefined` :\n\n[Typescript Playground Link](https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=false&ssl=13&ssc=2&pln=1&pc=1#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTILm7AHjwAdKmUyDw8yADkkPSlADTsKZxkXDSZfnkFXEUlpRAAHnAWTvLVtRxi4k2+2Z759eIdhB60EDUEOrr6COb0yKD0ikjIALzIVrb2DtgjaTRGZBBEIBBkVZcN1yC394-IOiFsGyC0dDyXIkdBMBw7MB7CDTMQUX64f6A4Gg8GQ6Gw7gIxGbIEw1EQgFQ4wwgoUXJgdAAGXQAHdoOI4IsHCEEUA)\n\nTurning on the `exactOptionalPropertyTypes` also doesn’t save us here since we didn’t have a type-issue anyway, but more of a logic issue. `makeFoo({ fieldB: undefined })` will still set `fieldB` to `example`.\n\n## Allowing bad inputs\n\nThis last approach takes the first and second approaches above and combines them using a `pickOrDefault` function. Here if any value is passed into the partial, we will return it, except when that value would be incorrect in the output type:\n\n```tsx\nfunction isValuePresent<T extends object>(obj: T, key: keyof T): boolean {\n    return key in obj;\n}\n\nfunction pickOrDefault<T extends object, K extends keyof T>(partial: T, key: K, fallbackValue: T[K]): T[K] {\n  if (key in partial) {\n    return partial[key];\n  }\n\n  return fallbackValue\n}\n\ninterface Foo {\n  fieldA: string;\n  fieldB?: string;\n  fieldC?: boolean | null;\n}\n\nfunction makeFoo(partial: Partial<Foo> = {}): Foo {\n  return {\n\t  fieldA: pickOrDefault(partial, 'fieldA', 'test') ?? 'test',\n    fieldB: pickOrDefault(partial, 'fieldB', 'example'),\n    fieldC: pickOrDefault(partial, 'fieldC', true),\n  };\n}\n\nconst instance = makeFoo({ fieldA: undefined, fieldB: undefined });\nconsole.log(instance.fieldA);\nconsole.log(instance.fieldB);\n\nconsole.log(instance.fieldA.toLowerCase());\n\n```\n\nFor each field, we prefer the input partial, except here the type mismatch for `fieldA` forced us to add the default value twice, once if the partial didn’t have a value, and once if the partial had `undefined` which isn’t allows in the final version of `type Foo`.\n\nWhile more verbose, this does eliminate the type holes the code!","contentHTML":"<p>I&#x27;ve discussed <a href=\"/blog/post/2023-08-14-partial-objects\">full and partial objects before on this blog</a>, and in this article I&#x27;m going to investigate a common factory pattern\nin Typescript that can lead to type-holes.\nWhen writing tests or complex components, I&#x27;ll often create prop factory utilities.</p>\n<p>For tests, the goal is to create props with all the default values, except a few that may be\noveridden for a specific test case. The function signature typically looks like this:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-jsx\">function makeFoo(partial?: Partial&lt;Foo&gt;): Foo;\n</code></pre></div>\n<p>The expectation is that a software developer can call <code>makeFoo</code> and get a version of <code>Foo</code> that has all the defaults set to use in tests. Then, if the developer want to override a few fields to test an edge case, all they do is call <code>makeFoo({ fieldA: &#x27;special-case })</code>.</p>\n<p>I’ve seen developers try to implement this a few ways, each with its pros and cons.</p>\n<h3>Spreading</h3>\n<p>The easiest way to implement this function is to just provide defaults and spread the partial:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-jsx\">interface Foo {\n  fieldA: string;\n  fieldB?: string;\n  fieldC?: boolean | null;\n}\n\nfunction makeFoo(partial?: Partial&lt;Foo&gt;): Foo {\n  return {\n\t  fieldA: &#x27;test&#x27;,\n    fieldB: &#x27;example&#x27;,\n    fieldC: false,\n    ...partial\n  };\n}\n</code></pre></div>\n<p>Here, we create a <code>Foo</code>  mock with overrides for the defaults, which are provided by <code>partial?: Partial&lt;Foo&gt;</code> . However, even though <code>fieldA</code> is required, we can see a type-hole with the default Typescript compilation settings:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-jsx\">const instance = makeFoo({ fieldA: undefined, fieldB: undefined, fieldC: undefined });\nconsole.log(instance.fieldA);\n\n// No type error, but this blows up\nconsole.log(instance.fieldA.toLowerCase());\n</code></pre></div>\n<p>When we spread, <code>undefined</code> actually overrides the default! But why were we allowed to provide <code>undefined</code> in the first place?</p>\n<p>In Typescript, <code>Partial&lt;Foo&gt;</code>  keeps all the fields, but makes them optional. In the default compilation settings, an optional field can be set to <code>undefined</code>.</p>\n<p><a href=\"https://www.typescriptlang.org/play/?#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTIAOSQ9BkANOwpnGRcNBkQAB5wFk7yeQUcYuI08CS0EPkEBAB0PS5uwB7sOrr6COb0yKD0ikjIALzIVrb2DtgNaTRGZBBEIBBkyDohbGMgtOjyXSToTA5TYDMQXamUx-oA9O-IAHJYYACeThQ0Cg6CguRk6jAyDAAAtgLQZNcAO6I9ROXCnc6Xa63e6PZ5FChdMDoAAy6GR0HEcDaDhCxyAA\">Typescript Playground Link</a></p>\n<p>There is a Typescript compilation flag to throw a type-error and keep our sanity: <code>exactOptionalPropertyTypes</code>. Enabling this flag makes Typescript show an error for <code>makeFoo({ fieldA: undefined, fieldB: undefined, fieldC: undefined });</code>. We can add the field to the call if it is set to a value.</p>\n<p><a href=\"https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTIAOSQ9BkANOwpnGRcNBkQAB5wFk7yeQUcYuI08CS0EPkEBAB0PS5uwB7sOrr6COb0yKD0ikjIALzIVrb2DtgNaTRGZBBEIBBkuevFmyDbu-uHqRInZ6D7yDohbGMgtOjyXSToTA5TYDMQLpXChPUbjd6Ar4-P4AoFFChdMDoAAy6AA7tBxHA2g4Qk8gA\">Typescript Playground Link</a></p>\n<p>But this causes another problem: it is perfectly valid to create an initial instance of <code>Foo</code> without fieldB being set (and its value being <code>undefined</code>). But now our <code>makeFoo</code> object doesn’t allow us to pass <code>fieldB: undefined</code> anymore. Only when the interface explicitly defines fieldB as optional AND undefined does it allow us to so.</p>\n<p><a href=\"https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQTZAB9kAVxBkIREBDJsCRUmQDCfZACNMJCHBCjkIcSRJsAvrlwxJCMMHQGAtnADWEDOgAUABzhR7OBINAAV-QJIAHk8APgBKGk8cdigIMHEoAzwASCVOShoAckh6QoAadjyVLiKIAA84Jx9dcsqOFVUaeBJaCAqCAgA6Yb8A4CD2cwsrBEd6ZFB6fSRkAF5kF3dPL2x27hpJaVl5ZHM4tlmQWnRdQZJ0Ji9FsGWIQeVyCnOZuZu3+8ez1e73yFEGYHQABl0AB3aCqOC9Lxxc5AA\">Typescript Playground Link</a></p>\n<p>Generally this pattern without the flag is fine for creating mock data, since any type-holes would only be scoped to tests and not real production code. But the question is: can we have <code>makeFoo</code> take a partial, return Foo without type-holes, and have allow <code>undefined</code> for partials?</p>\n<h2>Null-Coalescing Every Field</h2>\n<p>Another common implementation I have seen is to add nullish coalescing to every field:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-jsx\">interface Foo {\n  fieldA: string;\n  fieldB?: string;\n  fieldC?: boolean | null;\n}\n\nfunction makeFoo(partial?: Partial&lt;Foo&gt;): Foo {\n  return {\n\t  fieldA: partial?.fieldA ?? &#x27;test&#x27;,\n    fieldB: partial?.fieldB ?? &#x27;example&#x27;,\n    fieldC: partial?.fieldC ?? false,\n  };\n} \n</code></pre></div>\n<p>Let’s also turn off the <code>exactOptionalPropertyTypes</code> compilation flag for now.</p>\n<p>We know every field will be set correctly, so there are no type-holes in <code>Foo</code>, however, we still have the problem where we cannot override a field to the <code>unset</code> value of <code>undefined</code> :</p>\n<p><a href=\"https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=false&amp;ssl=13&amp;ssc=2&amp;pln=1&amp;pc=1#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTILm7AHjwAdKmUyDw8yADkkPSlADTsKZxkXDSZfnkFXEUlpRAAHnAWTvLVtRxi4k2+2Z759eIdhB60EDUEOrr6COb0yKD0ikjIALzIVrb2DtgjaTRGZBBEIBBkVZcN1yC394-IOiFsGyC0dDyXIkdBMBw7MB7CDTMQUX64f6A4Gg8GQ6Gw7gIxGbIEw1EQgFQ4wwgoUXJgdAAGXQAHdoOI4IsHCEEUA\">Typescript Playground Link</a></p>\n<p>Turning on the <code>exactOptionalPropertyTypes</code> also doesn’t save us here since we didn’t have a type-issue anyway, but more of a logic issue. <code>makeFoo({ fieldB: undefined })</code> will still set <code>fieldB</code> to <code>example</code>.</p>\n<h2>Allowing bad inputs</h2>\n<p>This last approach takes the first and second approaches above and combines them using a <code>pickOrDefault</code> function. Here if any value is passed into the partial, we will return it, except when that value would be incorrect in the output type:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">function isValuePresent&lt;T extends object&gt;(obj: T, key: keyof T): boolean {\n    return key in obj;\n}\n\nfunction pickOrDefault&lt;T extends object, K extends keyof T&gt;(partial: T, key: K, fallbackValue: T[K]): T[K] {\n  if (key in partial) {\n    return partial[key];\n  }\n\n  return fallbackValue\n}\n\ninterface Foo {\n  fieldA: string;\n  fieldB?: string;\n  fieldC?: boolean | null;\n}\n\nfunction makeFoo(partial: Partial&lt;Foo&gt; = {}): Foo {\n  return {\n\t  fieldA: pickOrDefault(partial, &#x27;fieldA&#x27;, &#x27;test&#x27;) ?? &#x27;test&#x27;,\n    fieldB: pickOrDefault(partial, &#x27;fieldB&#x27;, &#x27;example&#x27;),\n    fieldC: pickOrDefault(partial, &#x27;fieldC&#x27;, true),\n  };\n}\n\nconst instance = makeFoo({ fieldA: undefined, fieldB: undefined });\nconsole.log(instance.fieldA);\nconsole.log(instance.fieldB);\n\nconsole.log(instance.fieldA.toLowerCase());\n\n</code></pre></div>\n<p>For each field, we prefer the input partial, except here the type mismatch for <code>fieldA</code> forced us to add the default value twice, once if the partial didn’t have a value, and once if the partial had <code>undefined</code> which isn’t allows in the final version of <code>type Foo</code>.</p>\n<p>While more verbose, this does eliminate the type holes the code!</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    pre: \"pre\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"I've discussed \", _jsx(_components.a, {\n        href: \"/blog/post/2023-08-14-partial-objects\",\n        children: \"full and partial objects before on this blog\"\n      }), \", and in this article I'm going to investigate a common factory pattern\\nin Typescript that can lead to type-holes.\\nWhen writing tests or complex components, I'll often create prop factory utilities.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For tests, the goal is to create props with all the default values, except a few that may be\\noveridden for a specific test case. The function signature typically looks like this:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-jsx\",\n        children: \"function makeFoo(partial?: Partial<Foo>): Foo;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The expectation is that a software developer can call \", _jsx(_components.code, {\n        children: \"makeFoo\"\n      }), \" and get a version of \", _jsx(_components.code, {\n        children: \"Foo\"\n      }), \" that has all the defaults set to use in tests. Then, if the developer want to override a few fields to test an edge case, all they do is call \", _jsx(_components.code, {\n        children: \"makeFoo({ fieldA: 'special-case })\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I’ve seen developers try to implement this a few ways, each with its pros and cons.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Spreading\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The easiest way to implement this function is to just provide defaults and spread the partial:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-jsx\",\n        children: \"interface Foo {\\n  fieldA: string;\\n  fieldB?: string;\\n  fieldC?: boolean | null;\\n}\\n\\nfunction makeFoo(partial?: Partial<Foo>): Foo {\\n  return {\\n\\t  fieldA: 'test',\\n    fieldB: 'example',\\n    fieldC: false,\\n    ...partial\\n  };\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, we create a \", _jsx(_components.code, {\n        children: \"Foo\"\n      }), \"  mock with overrides for the defaults, which are provided by \", _jsx(_components.code, {\n        children: \"partial?: Partial<Foo>\"\n      }), \" . However, even though \", _jsx(_components.code, {\n        children: \"fieldA\"\n      }), \" is required, we can see a type-hole with the default Typescript compilation settings:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-jsx\",\n        children: \"const instance = makeFoo({ fieldA: undefined, fieldB: undefined, fieldC: undefined });\\nconsole.log(instance.fieldA);\\n\\n// No type error, but this blows up\\nconsole.log(instance.fieldA.toLowerCase());\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When we spread, \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \" actually overrides the default! But why were we allowed to provide \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \" in the first place?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In Typescript, \", _jsx(_components.code, {\n        children: \"Partial<Foo>\"\n      }), \"  keeps all the fields, but makes them optional. In the default compilation settings, an optional field can be set to \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play/?#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTIAOSQ9BkANOwpnGRcNBkQAB5wFk7yeQUcYuI08CS0EPkEBAB0PS5uwB7sOrr6COb0yKD0ikjIALzIVrb2DtgNaTRGZBBEIBBkyDohbGMgtOjyXSToTA5TYDMQXamUx-oA9O-IAHJYYACeThQ0Cg6CguRk6jAyDAAAtgLQZNcAO6I9ROXCnc6Xa63e6PZ5FChdMDoAAy6GR0HEcDaDhCxyAA\",\n        children: \"Typescript Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There is a Typescript compilation flag to throw a type-error and keep our sanity: \", _jsx(_components.code, {\n        children: \"exactOptionalPropertyTypes\"\n      }), \". Enabling this flag makes Typescript show an error for \", _jsx(_components.code, {\n        children: \"makeFoo({ fieldA: undefined, fieldB: undefined, fieldC: undefined });\"\n      }), \". We can add the field to the call if it is set to a value.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTIAOSQ9BkANOwpnGRcNBkQAB5wFk7yeQUcYuI08CS0EPkEBAB0PS5uwB7sOrr6COb0yKD0ikjIALzIVrb2DtgNaTRGZBBEIBBkuevFmyDbu-uHqRInZ6D7yDohbGMgtOjyXSToTA5TYDMQLpXChPUbjd6Ar4-P4AoFFChdMDoAAy6AA7tBxHA2g4Qk8gA\",\n        children: \"Typescript Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But this causes another problem: it is perfectly valid to create an initial instance of \", _jsx(_components.code, {\n        children: \"Foo\"\n      }), \" without fieldB being set (and its value being \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \"). But now our \", _jsx(_components.code, {\n        children: \"makeFoo\"\n      }), \" object doesn’t allow us to pass \", _jsx(_components.code, {\n        children: \"fieldB: undefined\"\n      }), \" anymore. Only when the interface explicitly defines fieldB as optional AND undefined does it allow us to so.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=true#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQTZAB9kAVxBkIREBDJsCRUmQDCfZACNMJCHBCjkIcSRJsAvrlwxJCMMHQGAtnADWEDOgAUABzhR7OBINAAV-QJIAHk8APgBKGk8cdigIMHEoAzwASCVOShoAckh6QoAadjyVLiKIAA84Jx9dcsqOFVUaeBJaCAqCAgA6Yb8A4CD2cwsrBEd6ZFB6fSRkAF5kF3dPL2x27hpJaVl5ZHM4tlmQWnRdQZJ0Ji9FsGWIQeVyCnOZuZu3+8ez1e73yFEGYHQABl0AB3aCqOC9Lxxc5AA\",\n        children: \"Typescript Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Generally this pattern without the flag is fine for creating mock data, since any type-holes would only be scoped to tests and not real production code. But the question is: can we have \", _jsx(_components.code, {\n        children: \"makeFoo\"\n      }), \" take a partial, return Foo without type-holes, and have allow \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \" for partials?\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Null-Coalescing Every Field\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another common implementation I have seen is to add nullish coalescing to every field:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-jsx\",\n        children: \"interface Foo {\\n  fieldA: string;\\n  fieldB?: string;\\n  fieldC?: boolean | null;\\n}\\n\\nfunction makeFoo(partial?: Partial<Foo>): Foo {\\n  return {\\n\\t  fieldA: partial?.fieldA ?? 'test',\\n    fieldB: partial?.fieldB ?? 'example',\\n    fieldC: partial?.fieldC ?? false,\\n  };\\n} \\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let’s also turn off the \", _jsx(_components.code, {\n        children: \"exactOptionalPropertyTypes\"\n      }), \" compilation flag for now.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We know every field will be set correctly, so there are no type-holes in \", _jsx(_components.code, {\n        children: \"Foo\"\n      }), \", however, we still have the problem where we cannot override a field to the \", _jsx(_components.code, {\n        children: \"unset\"\n      }), \" value of \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \" :\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play/?exactOptionalPropertyTypes=false&ssl=13&ssc=2&pln=1&pc=1#code/JYOwLgpgTgZghgYwgAgGIHt3IN4ChnIzAQA2AJgIIBcyAzmFKAOYDc+hx5AQgPw32MQrdkVJkAwn2QAjTCQhwQyAD7IQAVxIk2AX1y4Y6kAjDB0SgLZwA1hAzoAFAAc4UU3BJSACq-ckAPPYAfACUNPY47FAQYOpQSngAkASi5NTILm7AHjwAdKmUyDw8yADkkPSlADTsKZxkXDSZfnkFXEUlpRAAHnAWTvLVtRxi4k2+2Z759eIdhB60EDUEOrr6COb0yKD0ikjIALzIVrb2DtgjaTRGZBBEIBBkVZcN1yC394-IOiFsGyC0dDyXIkdBMBw7MB7CDTMQUX64f6A4Gg8GQ6Gw7gIxGbIEw1EQgFQ4wwgoUXJgdAAGXQAHdoOI4IsHCEEUA\",\n        children: \"Typescript Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Turning on the \", _jsx(_components.code, {\n        children: \"exactOptionalPropertyTypes\"\n      }), \" also doesn’t save us here since we didn’t have a type-issue anyway, but more of a logic issue. \", _jsx(_components.code, {\n        children: \"makeFoo({ fieldB: undefined })\"\n      }), \" will still set \", _jsx(_components.code, {\n        children: \"fieldB\"\n      }), \" to \", _jsx(_components.code, {\n        children: \"example\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Allowing bad inputs\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This last approach takes the first and second approaches above and combines them using a \", _jsx(_components.code, {\n        children: \"pickOrDefault\"\n      }), \" function. Here if any value is passed into the partial, we will return it, except when that value would be incorrect in the output type:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function isValuePresent<T extends object>(obj: T, key: keyof T): boolean {\\n    return key in obj;\\n}\\n\\nfunction pickOrDefault<T extends object, K extends keyof T>(partial: T, key: K, fallbackValue: T[K]): T[K] {\\n  if (key in partial) {\\n    return partial[key];\\n  }\\n\\n  return fallbackValue\\n}\\n\\ninterface Foo {\\n  fieldA: string;\\n  fieldB?: string;\\n  fieldC?: boolean | null;\\n}\\n\\nfunction makeFoo(partial: Partial<Foo> = {}): Foo {\\n  return {\\n\\t  fieldA: pickOrDefault(partial, 'fieldA', 'test') ?? 'test',\\n    fieldB: pickOrDefault(partial, 'fieldB', 'example'),\\n    fieldC: pickOrDefault(partial, 'fieldC', true),\\n  };\\n}\\n\\nconst instance = makeFoo({ fieldA: undefined, fieldB: undefined });\\nconsole.log(instance.fieldA);\\nconsole.log(instance.fieldB);\\n\\nconsole.log(instance.fieldA.toLowerCase());\\n\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For each field, we prefer the input partial, except here the type mismatch for \", _jsx(_components.code, {\n        children: \"fieldA\"\n      }), \" forced us to add the default value twice, once if the partial didn’t have a value, and once if the partial had \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \" which isn’t allows in the final version of \", _jsx(_components.code, {\n        children: \"type Foo\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While more verbose, this does eliminate the type holes the code!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nI've discussed [full and partial objects before on this blog](/blog/post/2023-08-14-partial-objects), and in this article I'm going to investigate a common factory pattern\nin Typescript that can lead to type-holes.\nWhen writing tests or complex components, I'll often create prop factory utilities.\n\n","excerptHTML":"<p>I&#x27;ve discussed <a href=\"/blog/post/2023-08-14-partial-objects\">full and partial objects before on this blog</a>, and in this article I&#x27;m going to investigate a common factory pattern\nin Typescript that can lead to type-holes.\nWhen writing tests or complex components, I&#x27;ll often create prop factory utilities.</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"I've discussed \", _jsx(_components.a, {\n      href: \"/blog/post/2023-08-14-partial-objects\",\n      children: \"full and partial objects before on this blog\"\n    }), \", and in this article I'm going to investigate a common factory pattern\\nin Typescript that can lead to type-holes.\\nWhen writing tests or complex components, I'll often create prop factory utilities.\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["technology","programming","react","typescript"]},{"slug":"2023-08-19-localization","date":"2023-08-19","title":"Enforcing Localization through Types","frontmatter":{"title":"Enforcing Localization through Types","tags":["typescript","react"]},"contentRaw":"\nWhen building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?\n\n## Defining a Localized Type\n\nTypeScript doesn't natively provide an [Opaque type](https://en.wikipedia.org/wiki/Opaque_data_type) that we can use to define a string that has already been localized. If the data looks like a string, TypeScript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in [type-fest](https://github.com/sindresorhus/type-fest):\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA)\n\nHere is a short example where we create a localized string and try to use a raw string and our localized string in a function:\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example('test')); // Will throw a type error\nconsole.log(example(createLocalizedString('test'))); // Works correctly\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA)\n\nNow we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\n\n## Enforcing in Components\n\nThe simplest way we can enforce that strings have already been localized is by using the type in our component's props interface:\n\n```tsx\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n```\n\nNow if we try to use that component without a localized string, we get an error:\n\n```tsx\nimport React from 'react';\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction Example() {\n    return (\n        <>\n            <Button label=\"Test\" />\n            <Button label={createLocalizedString(\"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA)\n\n## Localizing Strings\n\nSo far, we've been using a utility `createLocalizedString` to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we'll want to use a translation function from [react-i18next](https://github.com/i18next/react-i18next) or [next-i18next](https://github.com/i18next/next-i18next) to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\n\n```tsx\nimport React, { useCallback } from 'react';\nimport { Opaque } from 'type-fest';\nimport { useTranslation } from 'react-i18next';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) => {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        <>\n            <Button label={t(\"test\", \"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA)\n\nHere we use `useTranslation` from `react-i18next` and wrap the `t` translation function that is returned to override the type it gives us.\n\nNow when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\n","contentHTML":"<p>When building web applications, enforcing that strings be localized to the user&#x27;s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?</p>\n<h2>Defining a Localized Type</h2>\n<p>TypeScript doesn&#x27;t natively provide an <a href=\"https://en.wikipedia.org/wiki/Opaque_data_type\">Opaque type</a> that we can use to define a string that has already been localized. If the data looks like a string, TypeScript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in <a href=\"https://github.com/sindresorhus/type-fest\">type-fest</a>:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\">Playground example</a></p>\n<p>Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example(&#x27;test&#x27;)); // Will throw a type error\nconsole.log(example(createLocalizedString(&#x27;test&#x27;))); // Works correctly\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\">Playground example</a></p>\n<p>Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.</p>\n<h2>Enforcing in Components</h2>\n<p>The simplest way we can enforce that strings have already been localized is by using the type in our component&#x27;s props interface:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">interface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n</code></pre></div>\n<p>Now if we try to use that component without a localized string, we get an error:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">import React from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction Example() {\n    return (\n        &lt;&gt;\n            &lt;Button label=&quot;Test&quot; /&gt;\n            &lt;Button label={createLocalizedString(&quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\">Playground example</a></p>\n<h2>Localizing Strings</h2>\n<p>So far, we&#x27;ve been using a utility <code>createLocalizedString</code> to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we&#x27;ll want to use a translation function from <a href=\"https://github.com/i18next/react-i18next\">react-i18next</a> or <a href=\"https://github.com/i18next/next-i18next\">next-i18next</a> to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">import React, { useCallback } from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\nimport { useTranslation } from &#x27;react-i18next&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) =&gt; {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        &lt;&gt;\n            &lt;Button label={t(&quot;test&quot;, &quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\">Playground example</a></p>\n<p>Here we use <code>useTranslation</code> from <code>react-i18next</code> and wrap the <code>t</code> translation function that is returned to override the type it gives us.</p>\n<p>Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Defining a Localized Type\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"TypeScript doesn't natively provide an \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Opaque_data_type\",\n        children: \"Opaque type\"\n      }), \" that we can use to define a string that has already been localized. If the data looks like a string, TypeScript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in \", _jsx(_components.a, {\n        href: \"https://github.com/sindresorhus/type-fest\",\n        children: \"type-fest\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\nfunction example(s: LocalizedString) {\\n    return s;\\n}\\n\\nconsole.log(example('test')); // Will throw a type error\\nconsole.log(example(createLocalizedString('test'))); // Works correctly\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Enforcing in Components\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The simplest way we can enforce that strings have already been localized is by using the type in our component's props interface:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"interface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now if we try to use that component without a localized string, we get an error:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React from 'react';\\nimport { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction Example() {\\n    return (\\n        <>\\n            <Button label=\\\"Test\\\" />\\n            <Button label={createLocalizedString(\\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Localizing Strings\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So far, we've been using a utility \", _jsx(_components.code, {\n        children: \"createLocalizedString\"\n      }), \" to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we'll want to use a translation function from \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/react-i18next\",\n        children: \"react-i18next\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/next-i18next\",\n        children: \"next-i18next\"\n      }), \" to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React, { useCallback } from 'react';\\nimport { Opaque } from 'type-fest';\\nimport { useTranslation } from 'react-i18next';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction useLocalizedTranslation() {\\n    const { t : originalTranslate } = useTranslation();\\n\\n    const t = useCallback((key: string, defaultString: string) => {\\n        return originalTranslate(key, defaultString) as LocalizedString;\\n    }, [originalTranslate]);\\n\\n    return { t };\\n}\\n\\nfunction Example() {\\n    const { t } = useLocalizedTranslation();\\n    return (\\n        <>\\n            <Button label={t(\\\"test\\\", \\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we use \", _jsx(_components.code, {\n        children: \"useTranslation\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"react-i18next\"\n      }), \" and wrap the \", _jsx(_components.code, {\n        children: \"t\"\n      }), \" translation function that is returned to override the type it gives us.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?","excerptHTML":"<p>When building web applications, enforcing that strings be localized to the user&#x27;s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"When building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript","react"]},{"slug":"2023-08-17-feature-context","date":"2023-08-17","title":"Feature Contexts","frontmatter":{"title":"Feature Contexts","tags":["typescript","react"]},"contentRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).\n\n## Simple Example\n\nAs requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\n\n```tsx\n<button data-track=\"chat.form.send\">Send<button>\n```\n\nAnd as the tracking grows, these might get moved to a separate file and a constant/enumeration:\n\n```tsx\nconst ChatTracking = {\n  send: 'chat.form.send',\n  attachMedia: 'chat.form.attachMedia',\n  edit: 'chat.messages.edit',\n  delete: 'chat.messages.delete',\n} as const;\n\n// usage\n\n<button data-track={ChatTracking.send}>Send</button>\n```\n\nWe have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn't end up reducing any of the duplication.\n\n## Passing Namespaces\n\nAs the application grows more complex, an engineer working on another set of features ends up wanting to reuse the chat form from above. It already has some additional animation and composes the component library widgets, why not reuse it in the context of forums.\n\nExcept now the `data-track` attribute has to be passed in as a prop:\n\n```mermaid\ngraph TD\n  Forums --> ChatForm\n  Chat --> ChatForm\n  ChatForm --> SendButton\n  SendButton --> Button\n\n```\n\nThe Forums usage ends up adding its own tracking attribute, but ends up having to prop drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\n\n## Using Context\n\nInstead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\n\nFirst let's build a context in React:\n\n**FeatureContext.tsx**\n\n```tsx\nimport { createContext } from 'react';\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext<string[]>([]);\n```\n\nThen we'll create a helper component that we can use throughout the application:\n\n**Feature.tsx**\n\n```tsx\nimport type { ReactNode } from 'react';\nimport { useContext, useMemo } from 'react';\nimport { FeatureContext } from './FeatureContext';\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() => {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        <FeatureContext.Provider value={currentContext}>\n            {children}\n        </FeatureContext.Provider>\n    );\n}\n```\n\nUsage of this component would look like:\n\n```tsx\nfunction Forums() {\n  return (\n    <Feature name=\"forums\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction Chat() {\n  return (\n    <Feature name=\"chat\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction ChatForm() {\n  return (\n    <Feature name=\"form\">\n      <SendButton />\n    </Feature>\n  );\n}\n\n```\n\nThen, in SendButton, when we actually need to use the feature context, we construct the namespace:\n\n**SendButton.tsx**\n\n```tsx\nfunction SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\n  );\n}\n```\n\nNote: the above example has been simplified for this article's sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\n\nNo additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\n\n## Conclusion\n\nRather than trying to alleviate string duplication and prop drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop drilling the namespace down to every component.\n","contentHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>\n<h2>Simple Example</h2>\n<p>As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">&lt;button data-track=&quot;chat.form.send&quot;&gt;Send&lt;button&gt;\n</code></pre></div>\n<p>And as the tracking grows, these might get moved to a separate file and a constant/enumeration:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">const ChatTracking = {\n  send: &#x27;chat.form.send&#x27;,\n  attachMedia: &#x27;chat.form.attachMedia&#x27;,\n  edit: &#x27;chat.messages.edit&#x27;,\n  delete: &#x27;chat.messages.delete&#x27;,\n} as const;\n\n// usage\n\n&lt;button data-track={ChatTracking.send}&gt;Send&lt;/button&gt;\n</code></pre></div>\n<p>We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn&#x27;t end up reducing any of the duplication.</p>\n<h2>Passing Namespaces</h2>\n<p>As the application grows more complex, an engineer working on another set of features ends up wanting to reuse the chat form from above. It already has some additional animation and composes the component library widgets, why not reuse it in the context of forums.</p>\n<p>Except now the <code>data-track</code> attribute has to be passed in as a prop:</p>\n<mermaid chart=\"graph TD\n  Forums --&gt; ChatForm\n  Chat --&gt; ChatForm\n  ChatForm --&gt; SendButton\n  SendButton --&gt; Button\n\"></mermaid>\n<p>The Forums usage ends up adding its own tracking attribute, but ends up having to prop drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.</p>\n<h2>Using Context</h2>\n<p>Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.</p>\n<p>First let&#x27;s build a context in React:</p>\n<p><strong>FeatureContext.tsx</strong></p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">import { createContext } from &#x27;react&#x27;;\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext&lt;string[]&gt;([]);\n</code></pre></div>\n<p>Then we&#x27;ll create a helper component that we can use throughout the application:</p>\n<p><strong>Feature.tsx</strong></p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">import type { ReactNode } from &#x27;react&#x27;;\nimport { useContext, useMemo } from &#x27;react&#x27;;\nimport { FeatureContext } from &#x27;./FeatureContext&#x27;;\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() =&gt; {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        &lt;FeatureContext.Provider value={currentContext}&gt;\n            {children}\n        &lt;/FeatureContext.Provider&gt;\n    );\n}\n</code></pre></div>\n<p>Usage of this component would look like:</p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">function Forums() {\n  return (\n    &lt;Feature name=&quot;forums&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction Chat() {\n  return (\n    &lt;Feature name=&quot;chat&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction ChatForm() {\n  return (\n    &lt;Feature name=&quot;form&quot;&gt;\n      &lt;SendButton /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\n</code></pre></div>\n<p>Then, in SendButton, when we actually need to use the feature context, we construct the namespace:</p>\n<p><strong>SendButton.tsx</strong></p>\n<div class=\"overflow-auto rounded-2xl bg-[#0e005d6d] p-4 font-mono text-sm dark:bg-[#0e005d6d] dark:text-gray-100\"><pre><code class=\"language-tsx\">function SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    &lt;button data-track={[...featureContext, &#x27;send&#x27;].join(&#x27;.&#x27;)}&gt;Send&lt;/button&gt;\n  );\n}\n</code></pre></div>\n<p>Note: the above example has been simplified for this article&#x27;s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.</p>\n<p>No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.</p>\n<h2>Conclusion</h2>\n<p>Rather than trying to alleviate string duplication and prop drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop drilling the namespace down to every component.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    mermaid: \"mermaid\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n        children: \"track(namespace)\"\n      }), \").\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Simple Example\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"<button data-track=\\\"chat.form.send\\\">Send<button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And as the tracking grows, these might get moved to a separate file and a constant/enumeration:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"const ChatTracking = {\\n  send: 'chat.form.send',\\n  attachMedia: 'chat.form.attachMedia',\\n  edit: 'chat.messages.edit',\\n  delete: 'chat.messages.delete',\\n} as const;\\n\\n// usage\\n\\n<button data-track={ChatTracking.send}>Send</button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn't end up reducing any of the duplication.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Passing Namespaces\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the application grows more complex, an engineer working on another set of features ends up wanting to reuse the chat form from above. It already has some additional animation and composes the component library widgets, why not reuse it in the context of forums.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Except now the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute has to be passed in as a prop:\"]\n    }), \"\\n\", _jsx(_components.mermaid, {\n      chart: \"graph TD\\n  Forums --> ChatForm\\n  Chat --> ChatForm\\n  ChatForm --> SendButton\\n  SendButton --> Button\\n\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The Forums usage ends up adding its own tracking attribute, but ends up having to prop drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Using Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First let's build a context in React:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"FeatureContext.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { createContext } from 'react';\\n\\n/**\\n * Context for tracking features\\n */\\nexport const FeatureContext = createContext<string[]>([]);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then we'll create a helper component that we can use throughout the application:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Feature.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type { ReactNode } from 'react';\\nimport { useContext, useMemo } from 'react';\\nimport { FeatureContext } from './FeatureContext';\\n\\nexport interface FeatureProps {\\n    readonly name: string;\\n    readonly children: ReactNode;\\n    readonly topLevel?: boolean;\\n}\\n\\nexport function Feature({\\n    name,\\n    children,\\n    topLevel,\\n}: FeatureProps): JSX.Element {\\n    const parentContext = useContext(FeatureContext);\\n\\n    const currentContext = useMemo(() => {\\n        if (topLevel === true) {\\n            return [name];\\n        }\\n        return [...parentContext, name];\\n    }, [parentContext, name, topLevel]);\\n\\n    return (\\n        <FeatureContext.Provider value={currentContext}>\\n            {children}\\n        </FeatureContext.Provider>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Usage of this component would look like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function Forums() {\\n  return (\\n    <Feature name=\\\"forums\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction Chat() {\\n  return (\\n    <Feature name=\\\"chat\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction ChatForm() {\\n  return (\\n    <Feature name=\\\"form\\\">\\n      <SendButton />\\n    </Feature>\\n  );\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then, in SendButton, when we actually need to use the feature context, we construct the namespace:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"SendButton.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function SendButton() {\\n  const featureContext = useContext(FeatureContext);\\n\\n  return (\\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\\n  );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: the above example has been simplified for this article's sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rather than trying to alleviate string duplication and prop drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop drilling the namespace down to every component.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).","excerptHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n      children: \"data-track\"\n    }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n      children: \"track(namespace)\"\n    }), \").\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript","react"]}]},"__N_SSG":true}