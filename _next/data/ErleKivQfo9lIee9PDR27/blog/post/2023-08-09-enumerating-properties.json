{"pageProps":{"headTitle":"Forbidden Typescript: Enumerating Properties - idmontie's Portfolio","headKeywords":"typescript","post":{"slug":"2023-08-09-enumerating-properties","date":"2023-08-09","title":"Forbidden Typescript: Enumerating Properties","frontmatter":{"title":"Forbidden Typescript: Enumerating Properties","tags":["typescript"]},"contentRaw":"\nIn [“JavaScript: The Definitive Guide”](https://amzn.to/3rV5Xov), there are functions described in **6.5 Enumerating Properties** that probably shouldn’t be used in production code because they modify their input parameters: `extend`, `merge`, `restrict`, and `subtract`.\n\nLet’s re-create each one using more modern practices in Typescript that don’t modify the input parameters:\n\n```tsx\n/**\n * Create a new object that returns the properties of target, overwritten with the properties in props\n */\nfunction extend<T extends object, P extends object>(target: T, props: P): T & P {\n    return {...target, ...props};\n}\n```\n\nEven in a more modern implementation, I would never recommend this. It is almost always easier to write `{...a, ...b}` inline and have its meaning be more clear.\n\nNext we have merge, not to be confused with extend:\n\n```tsx\n/**\n * Create a new object that returns all the properties of target and props, but the properties\n * in target are left alone.\n */\nfunction merge<T extends object, P extends object>(target: T, props: P): T & P {\n    return {...props, ...target};\n}\n```\n\nSame thing here, even with a more type-safe implementation, it’s almost always more clear to have an inline spread of `{...b, ...a}`.\n\nA more interesting function implementation is `restrict`:\n\n```tsx\n/**\n * Create a new object that returns all the values in target that also exist in props.\n */\nfunction restrict<P extends object, T extends P>(target: T, props: P): Pick<T, keyof P> {\n    const t: Partial<T> = { ...target };\n\n    for (let key in target) {\n        if (!(key in props)) {\n            delete t[key];\n        }\n    }\n\n    return t as Pick<T, keyof P>;\n}\n\nconst obj1 = { a: 123, b: 222 };\nconst obj2 = { b: 0 };\n\nconsole.log(restrict(obj1, obj2)); // { b: 222 }\n```\n\nHere we end up cloning our target object in order to delete keys from it later. An alternative approach might be to only construct the object with keys in props in the first place. This implementation is at least type-safe and will give you the correct typings for the object returned from `restrict`.\n\nLastly, here is our type-safe version of `subtract`:\n\n```tsx\n/**\n * Create a new object that returns all the values in target that do not exist in props.\n */\nfunction subtract<T extends object, P extends object>(target: T, props: P): Omit<T, keyof P> {\n    const t: Partial<T> = { ...target };\n\n    for (let key in props) {\n        if (key in t) {\n            delete t[key as unknown as keyof T];\n        }\n    }\n\n    return t as Omit<T, keyof P>;\n}\n\nconsole.log(subtract(obj1, obj2)); // { a: 123 }\n```\n\nBoth the `restrict` and `subtract` make use of type assertions to tell the compiler we know the actual types of the objects and keys when we are removing keys. Without these assertions, `t` is still a `Partial<T>`, even after we delete the keys from the object.\n\n## Takeaway\n\nIt’s almost always more clear and more type-safe to merge objects using inline spread notation than trying to use a clever utility. There are cases though, like `restrict` and `subtract` where we can leverage the type system to write safer code. There is always a balance to find when trying to write utilities between making something easier for engineers, and adding additional compile time safety.\n","contentHTML":"<p>In <a href=\"https://amzn.to/3rV5Xov\">“JavaScript: The Definitive Guide”</a>, there are functions described in <strong>6.5 Enumerating Properties</strong> that probably shouldn’t be used in production code because they modify their input parameters: <code>extend</code>, <code>merge</code>, <code>restrict</code>, and <code>subtract</code>.</p>\n<p>Let’s re-create each one using more modern practices in Typescript that don’t modify the input parameters:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns the properties of target, overwritten with the properties in props\n */\nfunction extend&lt;T extends object, P extends object&gt;(target: T, props: P): T &amp; P {\n    return {...target, ...props};\n}\n</code></pre></div>\n<p>Even in a more modern implementation, I would never recommend this. It is almost always easier to write <code>{...a, ...b}</code> inline and have its meaning be more clear.</p>\n<p>Next we have merge, not to be confused with extend:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns all the properties of target and props, but the properties\n * in target are left alone.\n */\nfunction merge&lt;T extends object, P extends object&gt;(target: T, props: P): T &amp; P {\n    return {...props, ...target};\n}\n</code></pre></div>\n<p>Same thing here, even with a more type-safe implementation, it’s almost always more clear to have an inline spread of <code>{...b, ...a}</code>.</p>\n<p>A more interesting function implementation is <code>restrict</code>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns all the values in target that also exist in props.\n */\nfunction restrict&lt;P extends object, T extends P&gt;(target: T, props: P): Pick&lt;T, keyof P&gt; {\n    const t: Partial&lt;T&gt; = { ...target };\n\n    for (let key in target) {\n        if (!(key in props)) {\n            delete t[key];\n        }\n    }\n\n    return t as Pick&lt;T, keyof P&gt;;\n}\n\nconst obj1 = { a: 123, b: 222 };\nconst obj2 = { b: 0 };\n\nconsole.log(restrict(obj1, obj2)); // { b: 222 }\n</code></pre></div>\n<p>Here we end up cloning our target object in order to delete keys from it later. An alternative approach might be to only construct the object with keys in props in the first place. This implementation is at least type-safe and will give you the correct typings for the object returned from <code>restrict</code>.</p>\n<p>Lastly, here is our type-safe version of <code>subtract</code>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns all the values in target that do not exist in props.\n */\nfunction subtract&lt;T extends object, P extends object&gt;(target: T, props: P): Omit&lt;T, keyof P&gt; {\n    const t: Partial&lt;T&gt; = { ...target };\n\n    for (let key in props) {\n        if (key in t) {\n            delete t[key as unknown as keyof T];\n        }\n    }\n\n    return t as Omit&lt;T, keyof P&gt;;\n}\n\nconsole.log(subtract(obj1, obj2)); // { a: 123 }\n</code></pre></div>\n<p>Both the <code>restrict</code> and <code>subtract</code> make use of type assertions to tell the compiler we know the actual types of the objects and keys when we are removing keys. Without these assertions, <code>t</code> is still a <code>Partial&lt;T&gt;</code>, even after we delete the keys from the object.</p>\n<h2>Takeaway</h2>\n<p>It’s almost always more clear and more type-safe to merge objects using inline spread notation than trying to use a clever utility. There are cases though, like <code>restrict</code> and <code>subtract</code> where we can leverage the type system to write safer code. There is always a balance to find when trying to write utilities between making something easier for engineers, and adding additional compile time safety.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    code: \"code\",\n    pre: \"pre\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.a, {\n        href: \"https://amzn.to/3rV5Xov\",\n        children: \"“JavaScript: The Definitive Guide”\"\n      }), \", there are functions described in \", _jsx(_components.strong, {\n        children: \"6.5 Enumerating Properties\"\n      }), \" that probably shouldn’t be used in production code because they modify their input parameters: \", _jsx(_components.code, {\n        children: \"extend\"\n      }), \", \", _jsx(_components.code, {\n        children: \"merge\"\n      }), \", \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s re-create each one using more modern practices in Typescript that don’t modify the input parameters:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns the properties of target, overwritten with the properties in props\\n */\\nfunction extend<T extends object, P extends object>(target: T, props: P): T & P {\\n    return {...target, ...props};\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Even in a more modern implementation, I would never recommend this. It is almost always easier to write \", _jsx(_components.code, {\n        children: \"{...a, ...b}\"\n      }), \" inline and have its meaning be more clear.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next we have merge, not to be confused with extend:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns all the properties of target and props, but the properties\\n * in target are left alone.\\n */\\nfunction merge<T extends object, P extends object>(target: T, props: P): T & P {\\n    return {...props, ...target};\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Same thing here, even with a more type-safe implementation, it’s almost always more clear to have an inline spread of \", _jsx(_components.code, {\n        children: \"{...b, ...a}\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A more interesting function implementation is \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns all the values in target that also exist in props.\\n */\\nfunction restrict<P extends object, T extends P>(target: T, props: P): Pick<T, keyof P> {\\n    const t: Partial<T> = { ...target };\\n\\n    for (let key in target) {\\n        if (!(key in props)) {\\n            delete t[key];\\n        }\\n    }\\n\\n    return t as Pick<T, keyof P>;\\n}\\n\\nconst obj1 = { a: 123, b: 222 };\\nconst obj2 = { b: 0 };\\n\\nconsole.log(restrict(obj1, obj2)); // { b: 222 }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we end up cloning our target object in order to delete keys from it later. An alternative approach might be to only construct the object with keys in props in the first place. This implementation is at least type-safe and will give you the correct typings for the object returned from \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Lastly, here is our type-safe version of \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns all the values in target that do not exist in props.\\n */\\nfunction subtract<T extends object, P extends object>(target: T, props: P): Omit<T, keyof P> {\\n    const t: Partial<T> = { ...target };\\n\\n    for (let key in props) {\\n        if (key in t) {\\n            delete t[key as unknown as keyof T];\\n        }\\n    }\\n\\n    return t as Omit<T, keyof P>;\\n}\\n\\nconsole.log(subtract(obj1, obj2)); // { a: 123 }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Both the \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \" make use of type assertions to tell the compiler we know the actual types of the objects and keys when we are removing keys. Without these assertions, \", _jsx(_components.code, {\n        children: \"t\"\n      }), \" is still a \", _jsx(_components.code, {\n        children: \"Partial<T>\"\n      }), \", even after we delete the keys from the object.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaway\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It’s almost always more clear and more type-safe to merge objects using inline spread notation than trying to use a clever utility. There are cases though, like \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \" where we can leverage the type system to write safer code. There is always a balance to find when trying to write utilities between making something easier for engineers, and adding additional compile time safety.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nIn [“JavaScript: The Definitive Guide”](https://amzn.to/3rV5Xov), there are functions described in **6.5 Enumerating Properties** that probably shouldn’t be used in production code because they modify their input parameters: `extend`, `merge`, `restrict`, and `subtract`.","excerptHTML":"<p>In <a href=\"https://amzn.to/3rV5Xov\">“JavaScript: The Definitive Guide”</a>, there are functions described in <strong>6.5 Enumerating Properties</strong> that probably shouldn’t be used in production code because they modify their input parameters: <code>extend</code>, <code>merge</code>, <code>restrict</code>, and <code>subtract</code>.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_components.p, {\n    children: [\"In \", _jsx(_components.a, {\n      href: \"https://amzn.to/3rV5Xov\",\n      children: \"“JavaScript: The Definitive Guide”\"\n    }), \", there are functions described in \", _jsx(_components.strong, {\n      children: \"6.5 Enumerating Properties\"\n    }), \" that probably shouldn’t be used in production code because they modify their input parameters: \", _jsx(_components.code, {\n      children: \"extend\"\n    }), \", \", _jsx(_components.code, {\n      children: \"merge\"\n    }), \", \", _jsx(_components.code, {\n      children: \"restrict\"\n    }), \", and \", _jsx(_components.code, {\n      children: \"subtract\"\n    }), \".\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript"]},"previous":{"slug":"2023-08-10-get-class","date":"2023-08-10","title":"Forbidden Typescript: Get Class Name","frontmatter":{"title":"Forbidden Typescript: Get Class Name","tags":["typescript"]},"contentRaw":"\nWe don’t get a lot of information using `typeof` in JavaScript or TypeScript. At most, it tells us whether a value is `undefined`, `number`, `string`, or `object`. If you want to get the class name using a function, you can use the following extended version of `classOf` that is originally from “JavaScript: The Definitive Guide”:\n\n```tsx\nfunction classOf(obj: unknown) {\n    if (obj === null) return \"Null\";\n    if (typeof obj === \"undefined\") return \"Undefined\";\n\n    if (typeof obj === 'object') {\n        // Warning: this won't work if your Typescript is minified and class names are mangled.\n        return (obj as object).constructor.name;\n    }\n\n    if (typeof obj === 'function') {\n        // Warning: this won't work if your Typescript is minified and function names are mangled.\n        const possibleName = (obj as CallableFunction).name;\n        if (possibleName) {\n            return possibleName;\n        }\n    }\n\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\n\nconsole.log(classOf(null)); // \"Null\"\nconsole.log(classOf(undefined)); // \"Undefined\"\nconsole.log(classOf(1)); // \"Number\"\nconsole.log(classOf(\"foobar\")); // \"String\"\nconsole.log(classOf({})); // \"Object\"\nconsole.log(classOf([])); // \"Array\"\nconsole.log(classOf(new Date()))\n\nclass Test {}\nconsole.log(classOf(new Test())); // \"Test\"\n\nfunction test() {}\nconsole.log(classOf(test)); // \"test\"\n\nconsole.log(classOf(function () {})) // \"Function\"\n```\n\n[Playground Link](https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA)\n\nThis `classOf` function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.\n\n## Takeaways\n\nUnfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead `instanceof` should be used, or a static name attribute that cannot be modified.\n","contentHTML":"<p>We don’t get a lot of information using <code>typeof</code> in JavaScript or TypeScript. At most, it tells us whether a value is <code>undefined</code>, <code>number</code>, <code>string</code>, or <code>object</code>. If you want to get the class name using a function, you can use the following extended version of <code>classOf</code> that is originally from “JavaScript: The Definitive Guide”:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function classOf(obj: unknown) {\n    if (obj === null) return &quot;Null&quot;;\n    if (typeof obj === &quot;undefined&quot;) return &quot;Undefined&quot;;\n\n    if (typeof obj === &#x27;object&#x27;) {\n        // Warning: this won&#x27;t work if your Typescript is minified and class names are mangled.\n        return (obj as object).constructor.name;\n    }\n\n    if (typeof obj === &#x27;function&#x27;) {\n        // Warning: this won&#x27;t work if your Typescript is minified and function names are mangled.\n        const possibleName = (obj as CallableFunction).name;\n        if (possibleName) {\n            return possibleName;\n        }\n    }\n\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\n\nconsole.log(classOf(null)); // &quot;Null&quot;\nconsole.log(classOf(undefined)); // &quot;Undefined&quot;\nconsole.log(classOf(1)); // &quot;Number&quot;\nconsole.log(classOf(&quot;foobar&quot;)); // &quot;String&quot;\nconsole.log(classOf({})); // &quot;Object&quot;\nconsole.log(classOf([])); // &quot;Array&quot;\nconsole.log(classOf(new Date()))\n\nclass Test {}\nconsole.log(classOf(new Test())); // &quot;Test&quot;\n\nfunction test() {}\nconsole.log(classOf(test)); // &quot;test&quot;\n\nconsole.log(classOf(function () {})) // &quot;Function&quot;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA\">Playground Link</a></p>\n<p>This <code>classOf</code> function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.</p>\n<h2>Takeaways</h2>\n<p>Unfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead <code>instanceof</code> should be used, or a static name attribute that cannot be modified.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"We don’t get a lot of information using \", _jsx(_components.code, {\n        children: \"typeof\"\n      }), \" in JavaScript or TypeScript. At most, it tells us whether a value is \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \", \", _jsx(_components.code, {\n        children: \"number\"\n      }), \", \", _jsx(_components.code, {\n        children: \"string\"\n      }), \", or \", _jsx(_components.code, {\n        children: \"object\"\n      }), \". If you want to get the class name using a function, you can use the following extended version of \", _jsx(_components.code, {\n        children: \"classOf\"\n      }), \" that is originally from “JavaScript: The Definitive Guide”:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function classOf(obj: unknown) {\\n    if (obj === null) return \\\"Null\\\";\\n    if (typeof obj === \\\"undefined\\\") return \\\"Undefined\\\";\\n\\n    if (typeof obj === 'object') {\\n        // Warning: this won't work if your Typescript is minified and class names are mangled.\\n        return (obj as object).constructor.name;\\n    }\\n\\n    if (typeof obj === 'function') {\\n        // Warning: this won't work if your Typescript is minified and function names are mangled.\\n        const possibleName = (obj as CallableFunction).name;\\n        if (possibleName) {\\n            return possibleName;\\n        }\\n    }\\n\\n    return Object.prototype.toString.call(obj).slice(8, -1);\\n}\\n\\nconsole.log(classOf(null)); // \\\"Null\\\"\\nconsole.log(classOf(undefined)); // \\\"Undefined\\\"\\nconsole.log(classOf(1)); // \\\"Number\\\"\\nconsole.log(classOf(\\\"foobar\\\")); // \\\"String\\\"\\nconsole.log(classOf({})); // \\\"Object\\\"\\nconsole.log(classOf([])); // \\\"Array\\\"\\nconsole.log(classOf(new Date()))\\n\\nclass Test {}\\nconsole.log(classOf(new Test())); // \\\"Test\\\"\\n\\nfunction test() {}\\nconsole.log(classOf(test)); // \\\"test\\\"\\n\\nconsole.log(classOf(function () {})) // \\\"Function\\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA\",\n        children: \"Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This \", _jsx(_components.code, {\n        children: \"classOf\"\n      }), \" function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaways\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Unfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead \", _jsx(_components.code, {\n        children: \"instanceof\"\n      }), \" should be used, or a static name attribute that cannot be modified.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWe don’t get a lot of information using `typeof` in JavaScript or TypeScript. At most, it tells us whether a value is `undefined`, `number`, `string`, or `object`. If you want to get the class name using a function, you can use the following extended version of `classOf` that is originally from “JavaScript: The Definitive Guide”:","excerptHTML":"<p>We don’t get a lot of information using <code>typeof</code> in JavaScript or TypeScript. At most, it tells us whether a value is <code>undefined</code>, <code>number</code>, <code>string</code>, or <code>object</code>. If you want to get the class name using a function, you can use the following extended version of <code>classOf</code> that is originally from “JavaScript: The Definitive Guide”:</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_components.p, {\n    children: [\"We don’t get a lot of information using \", _jsx(_components.code, {\n      children: \"typeof\"\n    }), \" in JavaScript or TypeScript. At most, it tells us whether a value is \", _jsx(_components.code, {\n      children: \"undefined\"\n    }), \", \", _jsx(_components.code, {\n      children: \"number\"\n    }), \", \", _jsx(_components.code, {\n      children: \"string\"\n    }), \", or \", _jsx(_components.code, {\n      children: \"object\"\n    }), \". If you want to get the class name using a function, you can use the following extended version of \", _jsx(_components.code, {\n      children: \"classOf\"\n    }), \" that is originally from “JavaScript: The Definitive Guide”:\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript"]},"next":{"slug":"2023-08-07-object-create","date":"2023-08-07","title":"Forbidden Typescript: Using Object.create to clone","frontmatter":{"title":"Forbidden Typescript: Using Object.create to clone","tags":["typescript"]},"contentRaw":"\nIn “Javascript: The Definitive Guide” there is an example that uses `Object.inherit` to inherit the prototype change. JavaScript defines a method `Object.create` that creates a new object using the given argument as the prototype of that object. Translating the examples from The Definitive Guide to Typescript, it looks like:\n\n```tsx\nfunction inherit<T extends object>(obj: T): T {\n    return Object.create(obj);\n}\n\nclass MyObject {\n    public a: number;\n\n    constructor(a: number) {\n        this.a = a;\n    }\n}\nconst myObject = new MyObject(123);\nconst myClone = inherit(myObject);\n```\n\n[Playground Link](https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABDMALApgJxlAPAFUXQA8p0wATAZ0TgCMArdaAPgAp6GAuRfASh6EA3gChE4xJnRQQmJAHlGzKADoIUgIZkOjPgG4RAXxEiIAGw1UaAWQCeiptESiJiAA4g6ZmBEQaeYCAAtnRYBmISEAhUUJgg0HCYbP6IgSFYfM4RruJQqDBUKhqIALx+Bq7GxlFgMYhB9kpOZWDoAO6Idg7KbACMAEwAzPqm0VD1tgDCZgjopchoWDhsDd3QI6O1cGboKjMA5iuNjlD6iAD0585+PAODiNXR27sHR9OzZ5fOj1s7e3CHBrvVoLGIaSDoODATrHZSfK6xEDoERAA)\n\nHowever, we lied. Notice that in the above code, the `myClone` object was created without `a` being initialized.\n\n```tsx\nconsole.log(myObject); // { a: 123 }\nconsole.log(myClone); // {}\nconsole.log(myClone instanceof MyObject); // true\n```\n\nThis creates what is known as a *type-hole*: the Typescript compiler will not report any bugs when we try to use `myClone.a`.  That’s because we used `Object.create` which returns the `any` type. In the above example, if we tried to use `myClone.a` in a case where we expected a `number`, but got `undefined`, we can end up with runtime bugs that should have been caught by the compiler.\n\nWe can make the typings a little more clear by doing the following:\n\n```tsx\nfunction inherit<T extends object>(obj: T): Partial<T> {\n    return Object.create(obj);\n}\n```\n\nNow Typescript will report that the value of `myClone.a` might be undefined.\n\nLet’s improve this a bit more and create an object that inherits and freezes the data in the given object:\n\n```tsx\nfunction inheritAndFreeze<T extends object>(obj: T, values: Partial<T>): Readonly<Partial<T>> {\n    const properties: PropertyDescriptorMap = {};\n\n    Object.keys(obj).forEach((unsafeKey) => {\n        const key = unsafeKey as keyof T;\n        properties[key] = {\n            value: values[key] ?? undefined,\n            writable: false,\n            configurable: false,\n        };\n    })\n\n    return Object.create(obj, properties);\n}\n\nclass MyObject {\n    public a: number;\n\n    constructor(a: number) {\n        this.a = a;\n    }\n}\n\nconst myObject = new MyObject(123);\nconst myClone = inheritAndFreeze(myObject, { a: 123 });\n\nconsole.log(myClone); // { a: 123 }\nmyClone.a = 999; // Would throw \"Cannot assign to read only property 'a' of object '#<MyObject>' \"\n```\n\n[Playground Link](https://www.typescriptlang.org/play?ssl=29&ssc=102&pln=1&pc=1#code/GYVwdgxgLglg9mABDMALApgJxlAgmAEwDFN10AvdAHgBVF0APKdQgZ0TgCMArdaAPgAUXbgC5ENADSIAbgEMANiHStxABTmZYi2vwCU4gEro5BBAoCeVDVpg6a-fogDeAKEQfEEBKyiIADphw-liwKupBIVoWACIqENj+UHCYALJy-ogAvC4AvgDcru6eAPI8fFAAdADW6Baswjx6lcApAKJyEKiCguCscsDoANJ1etlObp5TXj5+tRbZiH0Dw3WIcuzzcMAShdOegcGhMCoA2vMAuouT+9PySuji98qs53VXAPwfS4TowCjoAiSYq3TwAd2wUDknAUj0QwEUrHQwIAkGj0d4wP8AOYgTDQ2HiBEKJHA0EFEGIXJ6IpTUhQPFIMq8aCVBImZiNbjSQ5RMKsPSFXJFCAKDbsVIWZkVFyU-wgGEwCDrcRgEAAW04WEKlMxvkwIGgKUEclVGq1mDGN32UFQMFYlTkizke08wuFrj1fnVUvK0EWYHQYMQkul0EEAEYAEwAZkFntmiB9AGEFAh0IsUBhIfhiKQKOhBD6w1BpM4VYhozGqfGE2BWHBYZU09iixZU+nBYgAPTdkO+ll+ZzCvWN9DNuCtlNpwOOru9yux1wL6fpx2LACcW-yPb7AHU4CAFARELagsGAETJuRgMBwPzimDYpDJRCkUwcMCWAKRUILADkcj-hwOwiDK-4AMRUKGfpQPwwEXkAA)\n\nIf we didn’t mark the return value as `Readonly<Partial<T>>`, and instead just had `Partial<T>` we would once again have a type-hole and `myClone.a = 999;` would be allowed by Typescript, but would throw an exception at runtime because property a is read only as a runtime constraint.\n\n## The Takeaway\n\nLet’s step back and really look at what `inherit` was doing. All it gave us was a template object, and if you read on [MDN about Inheritance and prototype chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain):\n\n> You may also see some legacy code using `[Object.create()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)` to build the inheritance chain. However, because this reassigns the `prototype` property and removes the `[constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor)` property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet.\n\nThe key here is to be wary of using utility functions built into the language that return the `any` type. Be careful what the Typescript constraints are and make sure you don’t have any type-holes when you are using these generic functions.\n","contentHTML":"<p>In “Javascript: The Definitive Guide” there is an example that uses <code>Object.inherit</code> to inherit the prototype change. JavaScript defines a method <code>Object.create</code> that creates a new object using the given argument as the prototype of that object. Translating the examples from The Definitive Guide to Typescript, it looks like:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function inherit&lt;T extends object&gt;(obj: T): T {\n    return Object.create(obj);\n}\n\nclass MyObject {\n    public a: number;\n\n    constructor(a: number) {\n        this.a = a;\n    }\n}\nconst myObject = new MyObject(123);\nconst myClone = inherit(myObject);\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABDMALApgJxlAPAFUXQA8p0wATAZ0TgCMArdaAPgAp6GAuRfASh6EA3gChE4xJnRQQmJAHlGzKADoIUgIZkOjPgG4RAXxEiIAGw1UaAWQCeiptESiJiAA4g6ZmBEQaeYCAAtnRYBmISEAhUUJgg0HCYbP6IgSFYfM4RruJQqDBUKhqIALx+Bq7GxlFgMYhB9kpOZWDoAO6Idg7KbACMAEwAzPqm0VD1tgDCZgjopchoWDhsDd3QI6O1cGboKjMA5iuNjlD6iAD0585+PAODiNXR27sHR9OzZ5fOj1s7e3CHBrvVoLGIaSDoODATrHZSfK6xEDoERAA\">Playground Link</a></p>\n<p>However, we lied. Notice that in the above code, the <code>myClone</code> object was created without <code>a</code> being initialized.</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">console.log(myObject); // { a: 123 }\nconsole.log(myClone); // {}\nconsole.log(myClone instanceof MyObject); // true\n</code></pre></div>\n<p>This creates what is known as a <em>type-hole</em>: the Typescript compiler will not report any bugs when we try to use <code>myClone.a</code>.  That’s because we used <code>Object.create</code> which returns the <code>any</code> type. In the above example, if we tried to use <code>myClone.a</code> in a case where we expected a <code>number</code>, but got <code>undefined</code>, we can end up with runtime bugs that should have been caught by the compiler.</p>\n<p>We can make the typings a little more clear by doing the following:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function inherit&lt;T extends object&gt;(obj: T): Partial&lt;T&gt; {\n    return Object.create(obj);\n}\n</code></pre></div>\n<p>Now Typescript will report that the value of <code>myClone.a</code> might be undefined.</p>\n<p>Let’s improve this a bit more and create an object that inherits and freezes the data in the given object:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function inheritAndFreeze&lt;T extends object&gt;(obj: T, values: Partial&lt;T&gt;): Readonly&lt;Partial&lt;T&gt;&gt; {\n    const properties: PropertyDescriptorMap = {};\n\n    Object.keys(obj).forEach((unsafeKey) =&gt; {\n        const key = unsafeKey as keyof T;\n        properties[key] = {\n            value: values[key] ?? undefined,\n            writable: false,\n            configurable: false,\n        };\n    })\n\n    return Object.create(obj, properties);\n}\n\nclass MyObject {\n    public a: number;\n\n    constructor(a: number) {\n        this.a = a;\n    }\n}\n\nconst myObject = new MyObject(123);\nconst myClone = inheritAndFreeze(myObject, { a: 123 });\n\nconsole.log(myClone); // { a: 123 }\nmyClone.a = 999; // Would throw &quot;Cannot assign to read only property &#x27;a&#x27; of object &#x27;#&lt;MyObject&gt;&#x27; &quot;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?ssl=29&amp;ssc=102&amp;pln=1&amp;pc=1#code/GYVwdgxgLglg9mABDMALApgJxlAgmAEwDFN10AvdAHgBVF0APKdQgZ0TgCMArdaAPgAUXbgC5ENADSIAbgEMANiHStxABTmZYi2vwCU4gEro5BBAoCeVDVpg6a-fogDeAKEQfEEBKyiIADphw-liwKupBIVoWACIqENj+UHCYALJy-ogAvC4AvgDcru6eAPI8fFAAdADW6Baswjx6lcApAKJyEKiCguCscsDoANJ1etlObp5TXj5+tRbZiH0Dw3WIcuzzcMAShdOegcGhMCoA2vMAuouT+9PySuji98qs53VXAPwfS4TowCjoAiSYq3TwAd2wUDknAUj0QwEUrHQwIAkGj0d4wP8AOYgTDQ2HiBEKJHA0EFEGIXJ6IpTUhQPFIMq8aCVBImZiNbjSQ5RMKsPSFXJFCAKDbsVIWZkVFyU-wgGEwCDrcRgEAAW04WEKlMxvkwIGgKUEclVGq1mDGN32UFQMFYlTkizke08wuFrj1fnVUvK0EWYHQYMQkul0EEAEYAEwAZkFntmiB9AGEFAh0IsUBhIfhiKQKOhBD6w1BpM4VYhozGqfGE2BWHBYZU09iixZU+nBYgAPTdkO+ll+ZzCvWN9DNuCtlNpwOOru9yux1wL6fpx2LACcW-yPb7AHU4CAFARELagsGAETJuRgMBwPzimDYpDJRCkUwcMCWAKRUILADkcj-hwOwiDK-4AMRUKGfpQPwwEXkAA\">Playground Link</a></p>\n<p>If we didn’t mark the return value as <code>Readonly&lt;Partial&lt;T&gt;&gt;</code>, and instead just had <code>Partial&lt;T&gt;</code> we would once again have a type-hole and <code>myClone.a = 999;</code> would be allowed by Typescript, but would throw an exception at runtime because property a is read only as a runtime constraint.</p>\n<h2>The Takeaway</h2>\n<p>Let’s step back and really look at what <code>inherit</code> was doing. All it gave us was a template object, and if you read on <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">MDN about Inheritance and prototype chaining</a>:</p>\n<blockquote class=\"border-l-4 border-gray-300 pl-4\">\n<p>You may also see some legacy code using <code>[Object.create()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)</code> to build the inheritance chain. However, because this reassigns the <code>prototype</code> property and removes the <code>[constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor)</code> property, it can be more error-prone, while performance gains may not be apparent if the constructors haven&#x27;t created any instances yet.</p>\n</blockquote>\n<p>The key here is to be wary of using utility functions built into the language that return the <code>any</code> type. Be careful what the Typescript constraints are and make sure you don’t have any type-holes when you are using these generic functions.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\",\n    em: \"em\",\n    h2: \"h2\",\n    blockquote: \"blockquote\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In “Javascript: The Definitive Guide” there is an example that uses \", _jsx(_components.code, {\n        children: \"Object.inherit\"\n      }), \" to inherit the prototype change. JavaScript defines a method \", _jsx(_components.code, {\n        children: \"Object.create\"\n      }), \" that creates a new object using the given argument as the prototype of that object. Translating the examples from The Definitive Guide to Typescript, it looks like:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function inherit<T extends object>(obj: T): T {\\n    return Object.create(obj);\\n}\\n\\nclass MyObject {\\n    public a: number;\\n\\n    constructor(a: number) {\\n        this.a = a;\\n    }\\n}\\nconst myObject = new MyObject(123);\\nconst myClone = inherit(myObject);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABDMALApgJxlAPAFUXQA8p0wATAZ0TgCMArdaAPgAp6GAuRfASh6EA3gChE4xJnRQQmJAHlGzKADoIUgIZkOjPgG4RAXxEiIAGw1UaAWQCeiptESiJiAA4g6ZmBEQaeYCAAtnRYBmISEAhUUJgg0HCYbP6IgSFYfM4RruJQqDBUKhqIALx+Bq7GxlFgMYhB9kpOZWDoAO6Idg7KbACMAEwAzPqm0VD1tgDCZgjopchoWDhsDd3QI6O1cGboKjMA5iuNjlD6iAD0585+PAODiNXR27sHR9OzZ5fOj1s7e3CHBrvVoLGIaSDoODATrHZSfK6xEDoERAA\",\n        children: \"Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, we lied. Notice that in the above code, the \", _jsx(_components.code, {\n        children: \"myClone\"\n      }), \" object was created without \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" being initialized.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"console.log(myObject); // { a: 123 }\\nconsole.log(myClone); // {}\\nconsole.log(myClone instanceof MyObject); // true\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This creates what is known as a \", _jsx(_components.em, {\n        children: \"type-hole\"\n      }), \": the Typescript compiler will not report any bugs when we try to use \", _jsx(_components.code, {\n        children: \"myClone.a\"\n      }), \".  That’s because we used \", _jsx(_components.code, {\n        children: \"Object.create\"\n      }), \" which returns the \", _jsx(_components.code, {\n        children: \"any\"\n      }), \" type. In the above example, if we tried to use \", _jsx(_components.code, {\n        children: \"myClone.a\"\n      }), \" in a case where we expected a \", _jsx(_components.code, {\n        children: \"number\"\n      }), \", but got \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \", we can end up with runtime bugs that should have been caught by the compiler.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can make the typings a little more clear by doing the following:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function inherit<T extends object>(obj: T): Partial<T> {\\n    return Object.create(obj);\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now Typescript will report that the value of \", _jsx(_components.code, {\n        children: \"myClone.a\"\n      }), \" might be undefined.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s improve this a bit more and create an object that inherits and freezes the data in the given object:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function inheritAndFreeze<T extends object>(obj: T, values: Partial<T>): Readonly<Partial<T>> {\\n    const properties: PropertyDescriptorMap = {};\\n\\n    Object.keys(obj).forEach((unsafeKey) => {\\n        const key = unsafeKey as keyof T;\\n        properties[key] = {\\n            value: values[key] ?? undefined,\\n            writable: false,\\n            configurable: false,\\n        };\\n    })\\n\\n    return Object.create(obj, properties);\\n}\\n\\nclass MyObject {\\n    public a: number;\\n\\n    constructor(a: number) {\\n        this.a = a;\\n    }\\n}\\n\\nconst myObject = new MyObject(123);\\nconst myClone = inheritAndFreeze(myObject, { a: 123 });\\n\\nconsole.log(myClone); // { a: 123 }\\nmyClone.a = 999; // Would throw \\\"Cannot assign to read only property 'a' of object '#<MyObject>' \\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?ssl=29&ssc=102&pln=1&pc=1#code/GYVwdgxgLglg9mABDMALApgJxlAgmAEwDFN10AvdAHgBVF0APKdQgZ0TgCMArdaAPgAUXbgC5ENADSIAbgEMANiHStxABTmZYi2vwCU4gEro5BBAoCeVDVpg6a-fogDeAKEQfEEBKyiIADphw-liwKupBIVoWACIqENj+UHCYALJy-ogAvC4AvgDcru6eAPI8fFAAdADW6Baswjx6lcApAKJyEKiCguCscsDoANJ1etlObp5TXj5+tRbZiH0Dw3WIcuzzcMAShdOegcGhMCoA2vMAuouT+9PySuji98qs53VXAPwfS4TowCjoAiSYq3TwAd2wUDknAUj0QwEUrHQwIAkGj0d4wP8AOYgTDQ2HiBEKJHA0EFEGIXJ6IpTUhQPFIMq8aCVBImZiNbjSQ5RMKsPSFXJFCAKDbsVIWZkVFyU-wgGEwCDrcRgEAAW04WEKlMxvkwIGgKUEclVGq1mDGN32UFQMFYlTkizke08wuFrj1fnVUvK0EWYHQYMQkul0EEAEYAEwAZkFntmiB9AGEFAh0IsUBhIfhiKQKOhBD6w1BpM4VYhozGqfGE2BWHBYZU09iixZU+nBYgAPTdkO+ll+ZzCvWN9DNuCtlNpwOOru9yux1wL6fpx2LACcW-yPb7AHU4CAFARELagsGAETJuRgMBwPzimDYpDJRCkUwcMCWAKRUILADkcj-hwOwiDK-4AMRUKGfpQPwwEXkAA\",\n        children: \"Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we didn’t mark the return value as \", _jsx(_components.code, {\n        children: \"Readonly<Partial<T>>\"\n      }), \", and instead just had \", _jsx(_components.code, {\n        children: \"Partial<T>\"\n      }), \" we would once again have a type-hole and \", _jsx(_components.code, {\n        children: \"myClone.a = 999;\"\n      }), \" would be allowed by Typescript, but would throw an exception at runtime because property a is read only as a runtime constraint.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"The Takeaway\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let’s step back and really look at what \", _jsx(_components.code, {\n        children: \"inherit\"\n      }), \" was doing. All it gave us was a template object, and if you read on \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\",\n        children: \"MDN about Inheritance and prototype chaining\"\n      }), \":\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"You may also see some legacy code using \", _jsx(_components.code, {\n          children: \"[Object.create()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\"\n        }), \" to build the inheritance chain. However, because this reassigns the \", _jsx(_components.code, {\n          children: \"prototype\"\n        }), \" property and removes the \", _jsx(_components.code, {\n          children: \"[constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor)\"\n        }), \" property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The key here is to be wary of using utility functions built into the language that return the \", _jsx(_components.code, {\n        children: \"any\"\n      }), \" type. Be careful what the Typescript constraints are and make sure you don’t have any type-holes when you are using these generic functions.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nIn “Javascript: The Definitive Guide” there is an example that uses `Object.inherit` to inherit the prototype change. JavaScript defines a method `Object.create` that creates a new object using the given argument as the prototype of that object. Translating the examples from The Definitive Guide to Typescript, it looks like:","excerptHTML":"<p>In “Javascript: The Definitive Guide” there is an example that uses <code>Object.inherit</code> to inherit the prototype change. JavaScript defines a method <code>Object.create</code> that creates a new object using the given argument as the prototype of that object. Translating the examples from The Definitive Guide to Typescript, it looks like:</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_components.p, {\n    children: [\"In “Javascript: The Definitive Guide” there is an example that uses \", _jsx(_components.code, {\n      children: \"Object.inherit\"\n    }), \" to inherit the prototype change. JavaScript defines a method \", _jsx(_components.code, {\n      children: \"Object.create\"\n    }), \" that creates a new object using the given argument as the prototype of that object. Translating the examples from The Definitive Guide to Typescript, it looks like:\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript"]}},"__N_SSG":true}