{"pageProps":{"posts":[{"slug":"2023-08-14-partial-objects","date":"2023-08-14","title":"Forbidden Typescript: full/partial objects","frontmatter":{"title":"Forbidden Typescript: full/partial objects","tags":["typescript"]},"contentRaw":"\nWhen trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\n\n```tsx\n/**\n * An example interface to demonstrate\n */\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial<KnownCodes> = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key in ['code1', 'code2', 'code3']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes as KnownCodes;\n}\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\nIn the above example, we know that `knownCodes` will have all the keys will have values for the interface `KnownCodes`. However, Typescript can’t infer that, so we have to cast the value.\n\nAs the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.\n\nOne way to get around this is to use an assert:\n\n```tsx\ntype RequireAll<T> = {\n  [K in keyof T]-?: T[K];\n};\n\nfunction ensureAllRequired<T>(obj: Partial<T>, template: RequireAll<T>): asserts obj is T {\n  for (const key in template) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial<KnownCodes> = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of ['code1', 'code2']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\n[Playground link](https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA)\n\nThe above code does a **************runtime************** check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.\n\nI have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:\n\n```tsx\n\nfunction ensureAllRequired<T>(obj: Partial<T>): asserts obj is T {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\n```\n\nThe above will let any empty object partial to pass the assert.\n\n## Takeaway\n\nThis ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.\n\nSince we have to create a template object anyway, it is almost always simpler to do the following:\n\n```tsx\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes = { ...TEMPALTE_CODES };\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of ['code1', 'code2', 'code3']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\n[Playground link](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA)\n\nHere we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like `code3`) to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.\n","contentHTML":"<p>When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * An example interface to demonstrate\n */\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial&lt;KnownCodes&gt; = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key in [&#x27;code1&#x27;, &#x27;code2&#x27;, &#x27;code3&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes as KnownCodes;\n}\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p>In the above example, we know that <code>knownCodes</code> will have all the keys will have values for the interface <code>KnownCodes</code>. However, Typescript can’t infer that, so we have to cast the value.</p>\n<p>As the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.</p>\n<p>One way to get around this is to use an assert:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">type RequireAll&lt;T&gt; = {\n  [K in keyof T]-?: T[K];\n};\n\nfunction ensureAllRequired&lt;T&gt;(obj: Partial&lt;T&gt;, template: RequireAll&lt;T&gt;): asserts obj is T {\n  for (const key in template) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial&lt;KnownCodes&gt; = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of [&#x27;code1&#x27;, &#x27;code2&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA\">Playground link</a></p>\n<p>The above code does a <strong><strong><strong><strong><strong><strong><strong>runtime</strong></strong></strong></strong></strong></strong></strong> check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.</p>\n<p>I have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">\nfunction ensureAllRequired&lt;T&gt;(obj: Partial&lt;T&gt;): asserts obj is T {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\n</code></pre></div>\n<p>The above will let any empty object partial to pass the assert.</p>\n<h2>Takeaway</h2>\n<p>This ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.</p>\n<p>Since we have to create a template object anyway, it is almost always simpler to do the following:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">interface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes = { ...TEMPALTE_CODES };\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of [&#x27;code1&#x27;, &#x27;code2&#x27;, &#x27;code3&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA\">Playground link</a></p>\n<p>Here we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like <code>code3</code>) to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    strong: \"strong\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * An example interface to demonstrate\\n */\\ninterface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes: Partial<KnownCodes> = {};\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key in ['code1', 'code2', 'code3']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  return knownCodes as KnownCodes;\\n}\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the above example, we know that \", _jsx(_components.code, {\n        children: \"knownCodes\"\n      }), \" will have all the keys will have values for the interface \", _jsx(_components.code, {\n        children: \"KnownCodes\"\n      }), \". However, Typescript can’t infer that, so we have to cast the value.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One way to get around this is to use an assert:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"type RequireAll<T> = {\\n  [K in keyof T]-?: T[K];\\n};\\n\\nfunction ensureAllRequired<T>(obj: Partial<T>, template: RequireAll<T>): asserts obj is T {\\n  for (const key in template) {\\n    if (obj[key] === undefined) {\\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\\n    }\\n  }\\n}\\n\\ninterface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nconst TEMPALTE_CODES: KnownCodes = {\\n  code1: -1,\\n  code2: -1,\\n  code3: -1,\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes: Partial<KnownCodes> = {};\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key of ['code1', 'code2']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\\n\\n  return knownCodes;\\n}\\n\\ncreateValuesForKnownCodes();\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA\",\n        children: \"Playground link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The above code does a \", _jsx(_components.strong, {\n        children: _jsx(_components.strong, {\n          children: _jsx(_components.strong, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.strong, {\n                children: _jsx(_components.strong, {\n                  children: _jsx(_components.strong, {\n                    children: \"runtime\"\n                  })\n                })\n              })\n            })\n          })\n        })\n      }), \" check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"\\nfunction ensureAllRequired<T>(obj: Partial<T>): asserts obj is T {\\n  for (const key in obj) {\\n    if (obj[key] === undefined) {\\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\\n    }\\n  }\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The above will let any empty object partial to pass the assert.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaway\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since we have to create a template object anyway, it is almost always simpler to do the following:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"interface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nconst TEMPALTE_CODES: KnownCodes = {\\n  code1: -1,\\n  code2: -1,\\n  code3: -1,\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes = { ...TEMPALTE_CODES };\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key of ['code1', 'code2', 'code3']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  return knownCodes;\\n}\\n\\ncreateValuesForKnownCodes();\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA\",\n        children: \"Playground link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like \", _jsx(_components.code, {\n        children: \"code3\"\n      }), \") to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:","excerptHTML":"<p>When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript"]},{"slug":"2023-08-13-reviewing-frontend-applications","date":"2023-08-13","title":"Reviewing Your Frontend Applications","frontmatter":{"title":"Reviewing Your Frontend Applications","tags":["frontend","onboarding","documentation"]},"contentRaw":"\nBelow are some notes I’ve taken from setting up new code repositories and onboarding new team members. Hopefully they can help improve your current documentation and notes to make onboarding a smooth process.\n\n## Onboarding\n\nWhen new members start, do you have processes and documentation in place to make onboarding easy?\n\n☐ Is your process written down?\n\n☐ Add a note for people onboarding continue to improve it when they walk through it. Every time a new members onboards, they should follow the documentation and update it with any missing steps or new errors and resolutions if they come across them.\n\n## Environment Setup\n\nPart of onboarding is getting your environment set up. Usually, a team will have a preferred IDE and environment set up so that it is easy to help each other if there are any problems.\n\n☐ Is the preferred IDE documented?\n\n☐ Are preferred 3rd party plugins that developers install listed and documented somewhere?\n\n☐ If there is a VPN, are all the VPN details documented?\n\n☐ Is the preferred Git usage documented? IE git-flow etc?\n\n## README\n\nEach repository should have a main README that acts as a starting point for people new to the project to read. This should be useful to people who have been at the company for years, all the way to someone new who has just received their laptop:\n\n☐ Does the README have all the steps to:\n\n1. Download\n2. Install\n3. Run\n4. Deploy\n5. Test\n\n☐ Architecture - Is the architecture documented? This doesn’t need to be all documented within the README, but the README should at least link out to external documentation that covers:\n\n1. Clients, servers, databases, 3rd party systems are documented\n2. Data flows between systems are documented\n\n☐  API Documentation - How is the API documented? This is similar to the architecture section.\n\n1. If your repo has components, is there a Storybook or similar site to document the interfaces?\n2. If your repo has web APIs, is there a OpenAPI spec that can be viewed?\n3. Other projects will want to document their APIs as well.\n\n☐ Design System - Similar to the API documentation, if there is a design system that is used or implemented, does your README call that out?\n\n1. Documentation - do you have a link to how to get to the documentation?\n2. Storybooks - is there already a live storybook link somewhere? Does your README document how to run the storybook as well?\n\n### Building and CI/CD\n\nIf your project is buildable or deployable, do you have documentation on the Build Pipeline and the CI/CD PIipelines? These are important to simplify and document. Someone new to the project should be able to follow the README in the repo to build the application and understand what happens when they push a commit to the repository.\n\n☐  Build Pipeline\n\n1. Can the app be built in one step?\n2. Is the pipeline modern?\n\n☐  CI/CD\n\n1. Is there a CI/CD runner?\n2. Is it documented?\n3. Are there lint guidelines?\n    1. Are they checked on the CI/CD?\n4. Are there unit tests?\n    1. Are they run on every commit?\n5. Are there pre-push and pre-commit hooks? You can use Husky to set these up\n\n### Testing\n\nAs mentioned above, running unit, integration, and e2e tests may be part of the CI/CD pipeline. Will new people who onboard be able to follow the repo’s README or some other document in order to understand how to test their changes? If there is code-coverage, how do new members of the team know where to find them?\n\n☐ Testing\n\n1. Is there a test pipeline\n2. Are there unit tests\n3. Are there automated code coverage reports?\n\n☐ Bundle Sizes\n\n1. Make sure tree shaking is happening correctly\n2. Analyze the bundle size with create-react-app or BundleSizeAnalyzer webpack plugin\n\n☐ Performance\n\n1. Analyze your web app for pagespeed, lighthouse rating, and [a11y](https://github.com/thecreazy/siteaudit)\n\n### External Services\n\nSometimes repositories are self-contained, but more often than not, a repository will pull external information from a service. This might be feature flags from providers like LaunchDarkly, or website content from a Content Management System (CMS). Do new members of the team need API keys for these services? Make sure to document any external services and how to access them.\n\n☐ CMS\n\n1. Are there a lot of text and content that is constantly updated?\n2. Is there a CMS already implemented?\n\n### Conclusion\n\nThis is not meant to be an exhaustive list of everything to think about concerning onboarding members to a project. Documentation is nice to have, but working with the team to understand what is missing and how to improve it goes a long way to keeping the team happy and productive.\n\nI highly recommend reviewing the onboarding process from time to time and making sure that it is easy to onboard. You never know when your computer will crash and you need to set up your entire environment again.\n","contentHTML":"<p>Below are some notes I’ve taken from setting up new code repositories and onboarding new team members. Hopefully they can help improve your current documentation and notes to make onboarding a smooth process.</p>\n<h2>Onboarding</h2>\n<p>When new members start, do you have processes and documentation in place to make onboarding easy?</p>\n<p>☐ Is your process written down?</p>\n<p>☐ Add a note for people onboarding continue to improve it when they walk through it. Every time a new members onboards, they should follow the documentation and update it with any missing steps or new errors and resolutions if they come across them.</p>\n<h2>Environment Setup</h2>\n<p>Part of onboarding is getting your environment set up. Usually, a team will have a preferred IDE and environment set up so that it is easy to help each other if there are any problems.</p>\n<p>☐ Is the preferred IDE documented?</p>\n<p>☐ Are preferred 3rd party plugins that developers install listed and documented somewhere?</p>\n<p>☐ If there is a VPN, are all the VPN details documented?</p>\n<p>☐ Is the preferred Git usage documented? IE git-flow etc?</p>\n<h2>README</h2>\n<p>Each repository should have a main README that acts as a starting point for people new to the project to read. This should be useful to people who have been at the company for years, all the way to someone new who has just received their laptop:</p>\n<p>☐ Does the README have all the steps to:</p>\n<ol>\n<li>Download</li>\n<li>Install</li>\n<li>Run</li>\n<li>Deploy</li>\n<li>Test</li>\n</ol>\n<p>☐ Architecture - Is the architecture documented? This doesn’t need to be all documented within the README, but the README should at least link out to external documentation that covers:</p>\n<ol>\n<li>Clients, servers, databases, 3rd party systems are documented</li>\n<li>Data flows between systems are documented</li>\n</ol>\n<p>☐  API Documentation - How is the API documented? This is similar to the architecture section.</p>\n<ol>\n<li>If your repo has components, is there a Storybook or similar site to document the interfaces?</li>\n<li>If your repo has web APIs, is there a OpenAPI spec that can be viewed?</li>\n<li>Other projects will want to document their APIs as well.</li>\n</ol>\n<p>☐ Design System - Similar to the API documentation, if there is a design system that is used or implemented, does your README call that out?</p>\n<ol>\n<li>Documentation - do you have a link to how to get to the documentation?</li>\n<li>Storybooks - is there already a live storybook link somewhere? Does your README document how to run the storybook as well?</li>\n</ol>\n<h3>Building and CI/CD</h3>\n<p>If your project is buildable or deployable, do you have documentation on the Build Pipeline and the CI/CD PIipelines? These are important to simplify and document. Someone new to the project should be able to follow the README in the repo to build the application and understand what happens when they push a commit to the repository.</p>\n<p>☐  Build Pipeline</p>\n<ol>\n<li>Can the app be built in one step?</li>\n<li>Is the pipeline modern?</li>\n</ol>\n<p>☐  CI/CD</p>\n<ol>\n<li>Is there a CI/CD runner?</li>\n<li>Is it documented?</li>\n<li>Are there lint guidelines?<!-- -->\n<ol>\n<li>Are they checked on the CI/CD?</li>\n</ol>\n</li>\n<li>Are there unit tests?<!-- -->\n<ol>\n<li>Are they run on every commit?</li>\n</ol>\n</li>\n<li>Are there pre-push and pre-commit hooks? You can use Husky to set these up</li>\n</ol>\n<h3>Testing</h3>\n<p>As mentioned above, running unit, integration, and e2e tests may be part of the CI/CD pipeline. Will new people who onboard be able to follow the repo’s README or some other document in order to understand how to test their changes? If there is code-coverage, how do new members of the team know where to find them?</p>\n<p>☐ Testing</p>\n<ol>\n<li>Is there a test pipeline</li>\n<li>Are there unit tests</li>\n<li>Are there automated code coverage reports?</li>\n</ol>\n<p>☐ Bundle Sizes</p>\n<ol>\n<li>Make sure tree shaking is happening correctly</li>\n<li>Analyze the bundle size with create-react-app or BundleSizeAnalyzer webpack plugin</li>\n</ol>\n<p>☐ Performance</p>\n<ol>\n<li>Analyze your web app for pagespeed, lighthouse rating, and <a href=\"https://github.com/thecreazy/siteaudit\">a11y</a></li>\n</ol>\n<h3>External Services</h3>\n<p>Sometimes repositories are self-contained, but more often than not, a repository will pull external information from a service. This might be feature flags from providers like LaunchDarkly, or website content from a Content Management System (CMS). Do new members of the team need API keys for these services? Make sure to document any external services and how to access them.</p>\n<p>☐ CMS</p>\n<ol>\n<li>Are there a lot of text and content that is constantly updated?</li>\n<li>Is there a CMS already implemented?</li>\n</ol>\n<h3>Conclusion</h3>\n<p>This is not meant to be an exhaustive list of everything to think about concerning onboarding members to a project. Documentation is nice to have, but working with the team to understand what is missing and how to improve it goes a long way to keeping the team happy and productive.</p>\n<p>I highly recommend reviewing the onboarding process from time to time and making sure that it is easy to onboard. You never know when your computer will crash and you need to set up your entire environment again.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    h3: \"h3\",\n    a: \"a\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Below are some notes I’ve taken from setting up new code repositories and onboarding new team members. Hopefully they can help improve your current documentation and notes to make onboarding a smooth process.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Onboarding\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When new members start, do you have processes and documentation in place to make onboarding easy?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Is your process written down?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Add a note for people onboarding continue to improve it when they walk through it. Every time a new members onboards, they should follow the documentation and update it with any missing steps or new errors and resolutions if they come across them.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Environment Setup\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Part of onboarding is getting your environment set up. Usually, a team will have a preferred IDE and environment set up so that it is easy to help each other if there are any problems.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Is the preferred IDE documented?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Are preferred 3rd party plugins that developers install listed and documented somewhere?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ If there is a VPN, are all the VPN details documented?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Is the preferred Git usage documented? IE git-flow etc?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"README\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Each repository should have a main README that acts as a starting point for people new to the project to read. This should be useful to people who have been at the company for years, all the way to someone new who has just received their laptop:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Does the README have all the steps to:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Download\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Install\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Run\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Deploy\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Test\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Architecture - Is the architecture documented? This doesn’t need to be all documented within the README, but the README should at least link out to external documentation that covers:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Clients, servers, databases, 3rd party systems are documented\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Data flows between systems are documented\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐  API Documentation - How is the API documented? This is similar to the architecture section.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"If your repo has components, is there a Storybook or similar site to document the interfaces?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"If your repo has web APIs, is there a OpenAPI spec that can be viewed?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Other projects will want to document their APIs as well.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Design System - Similar to the API documentation, if there is a design system that is used or implemented, does your README call that out?\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Documentation - do you have a link to how to get to the documentation?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Storybooks - is there already a live storybook link somewhere? Does your README document how to run the storybook as well?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Building and CI/CD\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If your project is buildable or deployable, do you have documentation on the Build Pipeline and the CI/CD PIipelines? These are important to simplify and document. Someone new to the project should be able to follow the README in the repo to build the application and understand what happens when they push a commit to the repository.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐  Build Pipeline\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Can the app be built in one step?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Is the pipeline modern?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐  CI/CD\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Is there a CI/CD runner?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Is it documented?\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Are there lint guidelines?\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Are they checked on the CI/CD?\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Are there unit tests?\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Are they run on every commit?\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Are there pre-push and pre-commit hooks? You can use Husky to set these up\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Testing\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As mentioned above, running unit, integration, and e2e tests may be part of the CI/CD pipeline. Will new people who onboard be able to follow the repo’s README or some other document in order to understand how to test their changes? If there is code-coverage, how do new members of the team know where to find them?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Testing\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Is there a test pipeline\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Are there unit tests\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Are there automated code coverage reports?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Bundle Sizes\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Make sure tree shaking is happening correctly\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Analyze the bundle size with create-react-app or BundleSizeAnalyzer webpack plugin\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ Performance\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Analyze your web app for pagespeed, lighthouse rating, and \", _jsx(_components.a, {\n          href: \"https://github.com/thecreazy/siteaudit\",\n          children: \"a11y\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"External Services\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sometimes repositories are self-contained, but more often than not, a repository will pull external information from a service. This might be feature flags from providers like LaunchDarkly, or website content from a Content Management System (CMS). Do new members of the team need API keys for these services? Make sure to document any external services and how to access them.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"☐ CMS\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Are there a lot of text and content that is constantly updated?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Is there a CMS already implemented?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is not meant to be an exhaustive list of everything to think about concerning onboarding members to a project. Documentation is nice to have, but working with the team to understand what is missing and how to improve it goes a long way to keeping the team happy and productive.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I highly recommend reviewing the onboarding process from time to time and making sure that it is easy to onboard. You never know when your computer will crash and you need to set up your entire environment again.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nBelow are some notes I’ve taken from setting up new code repositories and onboarding new team members. Hopefully they can help improve your current documentation and notes to make onboarding a smooth process.","excerptHTML":"<p>Below are some notes I’ve taken from setting up new code repositories and onboarding new team members. Hopefully they can help improve your current documentation and notes to make onboarding a smooth process.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"Below are some notes I’ve taken from setting up new code repositories and onboarding new team members. Hopefully they can help improve your current documentation and notes to make onboarding a smooth process.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["frontend","onboarding","documentation"]}],"projects":[{"slug":"2023-08-07-wax-cpp-tutorial","date":"2023-08-07","title":"WAX C++ NFT Tutorial","frontmatter":{"title":"WAX C++ NFT Tutorial","image":"/images/project-wax.jpg","description":"WAX smart contract development course that guides developers through the process of creating a non-fungible token (NFT) smart contract.\n","language_tags":["node","cpp"],"framework_tags":["wax","blockchain","nfts"],"view_link":"https://dev.to/idmontie/series/23860","github_link":"https://github.com/CapsuleCat/wax-nft-tutorial"},"contentRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\n\nIt is a great introduction to WAX smart contract development and the WAX ecosystem.\n","contentHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.</p>\n<p>It is a great introduction to WAX smart contract development and the WAX ecosystem.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"This is a 22 part series on DevTo that goes through the entire process of creating\\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is a great introduction to WAX smart contract development and the WAX ecosystem.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating","excerptHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"This is a 22 part series on DevTo that goes through the entire process of creating\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]},{"slug":"2023-08-04-lacework","date":"2023-08-04","title":"Lacework","frontmatter":{"title":"Lacework","image":"/images/project-lacework.png","description":"Cloud security monitoring at scale.\n","language_tags":["node","javascript","typescript","java"],"github_link":"https://github.com/lacework"},"contentRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\n","contentHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.","excerptHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]}]},"__N_SSG":true}