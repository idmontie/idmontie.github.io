{"pageProps":{"posts":[{"slug":"2023-08-11-smart-contract-security","date":"2023-08-11","title":"Smart Contract Security","frontmatter":{"title":"Smart Contract Security"},"contentRaw":"\nThe crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\n\nIn general, the best practices around Smart Contracts are the same for writing secure code in general.\n\n## Keep it Simple\n\nKeep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.\n\n## Write Small Functions\n\nWrite small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.\n\n## Linting\n\nLint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.\n\n## Unit Tests\n\nUnit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called **negative** tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.\n\n## Scan for Security Vulnerabilities\n\nScan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.\n\nThere are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use [slither](https://github.com/crytic/slither):\n\n```tsx\nnpm install slither\nslither .\n```\n\nThis may take a while to run, but it will scan the compiles contracts for security issues.\n\n## Compliance\n\nFor Ethereum Smart Contracts, you can also use [slither](https://github.com/crytic/slither) to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.\n\n## Wrapping it Up\n\nSecurity is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.\n","contentHTML":"<p>The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.</p>\n<p>In general, the best practices around Smart Contracts are the same for writing secure code in general.</p>\n<h2>Keep it Simple</h2>\n<p>Keep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.</p>\n<h2>Write Small Functions</h2>\n<p>Write small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.</p>\n<h2>Linting</h2>\n<p>Lint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.</p>\n<h2>Unit Tests</h2>\n<p>Unit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called <strong>negative</strong> tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.</p>\n<h2>Scan for Security Vulnerabilities</h2>\n<p>Scan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.</p>\n<p>There are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use <a href=\"https://github.com/crytic/slither\">slither</a>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">npm install slither\nslither .\n</code></pre></div>\n<p>This may take a while to run, but it will scan the compiles contracts for security issues.</p>\n<h2>Compliance</h2>\n<p>For Ethereum Smart Contracts, you can also use <a href=\"https://github.com/crytic/slither\">slither</a> to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.</p>\n<h2>Wrapping it Up</h2>\n<p>Security is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    strong: \"strong\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In general, the best practices around Smart Contracts are the same for writing secure code in general.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Keep it Simple\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Keep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Write Small Functions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Write small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Linting\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Unit Tests\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Unit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called \", _jsx(_components.strong, {\n        children: \"negative\"\n      }), \" tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Scan for Security Vulnerabilities\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Scan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use \", _jsx(_components.a, {\n        href: \"https://github.com/crytic/slither\",\n        children: \"slither\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"npm install slither\\nslither .\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This may take a while to run, but it will scan the compiles contracts for security issues.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Compliance\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For Ethereum Smart Contracts, you can also use \", _jsx(_components.a, {\n        href: \"https://github.com/crytic/slither\",\n        children: \"slither\"\n      }), \" to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Wrapping it Up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Security is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThe crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.","excerptHTML":"<p>The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"slug":"2023-08-10-get-class","date":"2023-08-10","title":"Forbidden Typescript: Get Class Name","frontmatter":{"title":"Forbidden Typescript: Get Class Name"},"contentRaw":"\nWe don’t get a lot of information using `typeof` in JavaScript or TypeScript. At most, it tells us whether a value is `undefined`, `number`, `string`, or `object`. If you want to get the class name using a function, you can use the following extended version of `classOf` that is originally from “JavaScript: The Definitive Guide”:\n\n```tsx\nfunction classOf(obj: unknown) {\n    if (obj === null) return \"Null\";\n    if (typeof obj === \"undefined\") return \"Undefined\";\n\n    if (typeof obj === 'object') {\n        // Warning: this won't work if your Typescript is minified and class names are mangled.\n        return (obj as object).constructor.name;\n    }\n\n    if (typeof obj === 'function') {\n        // Warning: this won't work if your Typescript is minified and function names are mangled.\n        const possibleName = (obj as CallableFunction).name;\n        if (possibleName) {\n            return possibleName;\n        }\n    }\n\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\n\nconsole.log(classOf(null)); // \"Null\"\nconsole.log(classOf(undefined)); // \"Undefined\"\nconsole.log(classOf(1)); // \"Number\"\nconsole.log(classOf(\"foobar\")); // \"String\"\nconsole.log(classOf({})); // \"Object\"\nconsole.log(classOf([])); // \"Array\"\nconsole.log(classOf(new Date()))\n\nclass Test {}\nconsole.log(classOf(new Test())); // \"Test\"\n\nfunction test() {}\nconsole.log(classOf(test)); // \"test\"\n\nconsole.log(classOf(function () {})) // \"Function\"\n```\n\n[Playground Link](https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA)\n\nThis `classOf` function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.\n\n## Takeaways\n\nUnfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead `instanceof` should be used, or a static name attribute that cannot be modified.\n","contentHTML":"<p>We don’t get a lot of information using <code>typeof</code> in JavaScript or TypeScript. At most, it tells us whether a value is <code>undefined</code>, <code>number</code>, <code>string</code>, or <code>object</code>. If you want to get the class name using a function, you can use the following extended version of <code>classOf</code> that is originally from “JavaScript: The Definitive Guide”:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function classOf(obj: unknown) {\n    if (obj === null) return &quot;Null&quot;;\n    if (typeof obj === &quot;undefined&quot;) return &quot;Undefined&quot;;\n\n    if (typeof obj === &#x27;object&#x27;) {\n        // Warning: this won&#x27;t work if your Typescript is minified and class names are mangled.\n        return (obj as object).constructor.name;\n    }\n\n    if (typeof obj === &#x27;function&#x27;) {\n        // Warning: this won&#x27;t work if your Typescript is minified and function names are mangled.\n        const possibleName = (obj as CallableFunction).name;\n        if (possibleName) {\n            return possibleName;\n        }\n    }\n\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\n\nconsole.log(classOf(null)); // &quot;Null&quot;\nconsole.log(classOf(undefined)); // &quot;Undefined&quot;\nconsole.log(classOf(1)); // &quot;Number&quot;\nconsole.log(classOf(&quot;foobar&quot;)); // &quot;String&quot;\nconsole.log(classOf({})); // &quot;Object&quot;\nconsole.log(classOf([])); // &quot;Array&quot;\nconsole.log(classOf(new Date()))\n\nclass Test {}\nconsole.log(classOf(new Test())); // &quot;Test&quot;\n\nfunction test() {}\nconsole.log(classOf(test)); // &quot;test&quot;\n\nconsole.log(classOf(function () {})) // &quot;Function&quot;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA\">Playground Link</a></p>\n<p>This <code>classOf</code> function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.</p>\n<h2>Takeaways</h2>\n<p>Unfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead <code>instanceof</code> should be used, or a static name attribute that cannot be modified.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"We don’t get a lot of information using \", _jsx(_components.code, {\n        children: \"typeof\"\n      }), \" in JavaScript or TypeScript. At most, it tells us whether a value is \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \", \", _jsx(_components.code, {\n        children: \"number\"\n      }), \", \", _jsx(_components.code, {\n        children: \"string\"\n      }), \", or \", _jsx(_components.code, {\n        children: \"object\"\n      }), \". If you want to get the class name using a function, you can use the following extended version of \", _jsx(_components.code, {\n        children: \"classOf\"\n      }), \" that is originally from “JavaScript: The Definitive Guide”:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function classOf(obj: unknown) {\\n    if (obj === null) return \\\"Null\\\";\\n    if (typeof obj === \\\"undefined\\\") return \\\"Undefined\\\";\\n\\n    if (typeof obj === 'object') {\\n        // Warning: this won't work if your Typescript is minified and class names are mangled.\\n        return (obj as object).constructor.name;\\n    }\\n\\n    if (typeof obj === 'function') {\\n        // Warning: this won't work if your Typescript is minified and function names are mangled.\\n        const possibleName = (obj as CallableFunction).name;\\n        if (possibleName) {\\n            return possibleName;\\n        }\\n    }\\n\\n    return Object.prototype.toString.call(obj).slice(8, -1);\\n}\\n\\nconsole.log(classOf(null)); // \\\"Null\\\"\\nconsole.log(classOf(undefined)); // \\\"Undefined\\\"\\nconsole.log(classOf(1)); // \\\"Number\\\"\\nconsole.log(classOf(\\\"foobar\\\")); // \\\"String\\\"\\nconsole.log(classOf({})); // \\\"Object\\\"\\nconsole.log(classOf([])); // \\\"Array\\\"\\nconsole.log(classOf(new Date()))\\n\\nclass Test {}\\nconsole.log(classOf(new Test())); // \\\"Test\\\"\\n\\nfunction test() {}\\nconsole.log(classOf(test)); // \\\"test\\\"\\n\\nconsole.log(classOf(function () {})) // \\\"Function\\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA\",\n        children: \"Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This \", _jsx(_components.code, {\n        children: \"classOf\"\n      }), \" function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaways\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Unfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead \", _jsx(_components.code, {\n        children: \"instanceof\"\n      }), \" should be used, or a static name attribute that cannot be modified.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWe don’t get a lot of information using `typeof` in JavaScript or TypeScript. At most, it tells us whether a value is `undefined`, `number`, `string`, or `object`. If you want to get the class name using a function, you can use the following extended version of `classOf` that is originally from “JavaScript: The Definitive Guide”:","excerptHTML":"<p>We don’t get a lot of information using <code>typeof</code> in JavaScript or TypeScript. At most, it tells us whether a value is <code>undefined</code>, <code>number</code>, <code>string</code>, or <code>object</code>. If you want to get the class name using a function, you can use the following extended version of <code>classOf</code> that is originally from “JavaScript: The Definitive Guide”:</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_components.p, {\n    children: [\"We don’t get a lot of information using \", _jsx(_components.code, {\n      children: \"typeof\"\n    }), \" in JavaScript or TypeScript. At most, it tells us whether a value is \", _jsx(_components.code, {\n      children: \"undefined\"\n    }), \", \", _jsx(_components.code, {\n      children: \"number\"\n    }), \", \", _jsx(_components.code, {\n      children: \"string\"\n    }), \", or \", _jsx(_components.code, {\n      children: \"object\"\n    }), \". If you want to get the class name using a function, you can use the following extended version of \", _jsx(_components.code, {\n      children: \"classOf\"\n    }), \" that is originally from “JavaScript: The Definitive Guide”:\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"}],"projects":[{"slug":"2023-08-07-wax-cpp-tutorial","date":"2023-08-07","title":"WAX C++ NFT Tutorial","frontmatter":{"title":"WAX C++ NFT Tutorial","image":"/images/project-wax.jpg","description":"WAX smart contract development course that guides developers through the process of creating a non-fungible token (NFT) smart contract.\n","language_tags":["node","cpp"],"framework_tags":["wax","blockchain","nfts"],"view_link":"https://dev.to/idmontie/series/23860","github_link":"https://github.com/CapsuleCat/wax-nft-tutorial"},"contentRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\n\nIt is a great introduction to WAX smart contract development and the WAX ecosystem.\n","contentHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.</p>\n<p>It is a great introduction to WAX smart contract development and the WAX ecosystem.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"This is a 22 part series on DevTo that goes through the entire process of creating\\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is a great introduction to WAX smart contract development and the WAX ecosystem.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating","excerptHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"This is a 22 part series on DevTo that goes through the entire process of creating\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"slug":"2023-08-04-lacework","date":"2023-08-04","title":"Lacework","frontmatter":{"title":"Lacework","image":"/images/project-lacework.png","description":"Cloud security monitoring at scale.\n","language_tags":["node","javascript","typescript","java"],"github_link":"https://github.com/lacework"},"contentRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\n","contentHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.","excerptHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"}]},"__N_SSG":true}