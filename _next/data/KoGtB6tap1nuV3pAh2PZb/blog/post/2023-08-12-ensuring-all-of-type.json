{"pageProps":{"headTitle":"Forbidden Typescript: ensuring all of a type - idmontie's Portfolio","post":{"slug":"2023-08-12-ensuring-all-of-type","date":"2023-08-12","title":"Forbidden Typescript: ensuring all of a type","frontmatter":{"title":"Forbidden Typescript: ensuring all of a type"},"contentRaw":"\nWhen creating more complex systems, there are times where you will want to ensure that an array contains every value of a defined type. We have a union of primitive literal types to define the possible values a type can have:\n\n```tsx\ntype Colors = 'red' | 'green' | 'blue';\n```\n\nThen, throughout our codebase, we can use the `Color` type to ensure functions can only be called with those values:\n\n```tsx\naddColor(name: Colors);\n```\n\nBut, we may want to make sure that when we create a new possible value for the type, we don’t forget to use that value to do some initialization:\n\n```tsx\nfunction initColors() {\n  addColor('red')\n  addColor('green');\n  addColor('blue');\n}\n```\n\nThere are a few ways to do this, one would be to create a record that must contain every color:\n\n```tsx\nconst allColors: Record<Colors, boolean> = {\n    red: true,\n    green: true,\n    blue: true,\n};\n\nfunction initColorsUsingRecord() {\n    (Object.keys(allColors) as Colors[]).forEach((color) => {\n        addColor(color);\n    });\n}\n```\n\nIn the above snippet, we create a record that will have every `Colors` type as a key, and Typescript will complain when we add a new literal type to the `Colors` union and forget to add it to the record.\n\nNotice though that we end up just getting the list of keys in `allColors` as an array anyway, then casting that type to help with the type-hinting for `Object.keys`.\n\nWe can also ensure that we create an array with every value of a given type:\n\n```tsx\n/**\n * Generator function to create functions that will throw typing exceptions when\n * the given array does not contain all values of the type\n */\nfunction ensureAllOf<T>() {\n    return <U extends T[]>(array: U & ([T] extends [U[number]] ? unknown : \"Invalid\")) => array;\n}\n\ntype Color = 'red' | 'green' | 'blue';\nconst ensureAllColors = ensureAllOf<Color>();\nconst colors = ensureAllColors(['red', 'green', 'blue']);\n\nfunction addColor(color: Color) {\n    // just a stub\n}\n\nfunction initColorsUsingEnsure() {\n    colors.forEach(color => {\n        addColor(color);\n    });\n}\n```\n\n[Typescript Playground](https://www.typescriptlang.org/play?#code/PQKhCgAIUhxBTAdvATgQwC4HsWQGYCuiAxhgJZaKTaTErybz5GkWIDO1AFppAO5kANoO4osfagE8ADmUQBzSPAAexeNPKVOfLkigwMuyPLIA3JJDQp0kyABMs8ToiwZalDGjmXhkU2kECJ0gsPG4mDBl4fWBwQhJNKiR2AnoAQWEAeTwAHgAVAD4ACgBKSABvKEhq+gxUqhyAVSVlDCQ7TjyAbQBdYqsbAC5IZoAySCKuvJ6WtsQOyC7GrsQCAFsAI1QemYB+SCIAaxc+KmGAIgBJRH9BMjtzkrKAXgLLazRJAG5wAF9wcCRaRMADCWEEOEgz0gAHJ6HYYZAAD6w+T0JCIlEwjaBeAwn7ELRuZKpeAZQRgiEoTjQknpLK5Sk4YolAlE9xUmlKDik8lM6mTOHwBEAGlR6MQMLF2NxMJ6rIB8VYlEsdjs-KKhKpw35ZUq1WqwGAkAAVgR2G40JALQQNn9FSxEpA5GQMPz2I12HJ5ABRHn0UoVKrVLU4dgAOjwOB9aGIXE14MhryDBtTqvViZQCapCtTvwVvyAA)\n\nIn the above example, we have a template `ensureAllOf` that takes a type and spits out a function that takes an array of that type and will throw a typing error if that array does not contain all of the possible values.\n\nIf we add “yellow” to the `Colors` type, then `ensureAllColors` will remind us that we need to add “yellow” to the list of values\n\n## Takeaway\n\nWhile `ensureAllOf` may come in handy in some cases, it is almost always easier to use an enumeration:\n\n```tsx\nenum Color {\n    red = 'red',\n    green = 'green',\n    blue = 'blue'\n}\n\nfunction addColor(color: Color) {\n    console.log('init', color);\n}\n\nconst colors = Object.values(Color);\n\nfunction initColorsUsingEnsure() {\n    colors.forEach(color => {\n        addColor(color);\n    });\n}\ninitColorsUsingEnsure();\n```\n\n[Typescript Playground](https://www.typescriptlang.org/play?#code/KYOwrgtgBAwg9gGzgJygbwFBW1ZwAmUAvFAOR76kA0WOA5nqMWQ8KNbdgEYJjDOkefUhgC+GDADMwIAMYAXAJZwQUAIb588JMgAUsxCgBcsQ8gCU6TlAMgAzomAA6JHV2lFIRfOo2z5gG4xCVs7eT8dO2YAeS4AK2AFJwA3NV5gO11tFECJaTklFShPb2zkOwBVO086AFF7MDxdS0wcCJQ7J0kUWrVZAAt9M2IAPis2to0tMyGdXLbRXPES+TLK6pA6hqbAoA)\n\nUsing an enumeration, there is no need to write a type and have to add the new value to the ensureOfAll array.\n","contentHTML":"<p>When creating more complex systems, there are times where you will want to ensure that an array contains every value of a defined type. We have a union of primitive literal types to define the possible values a type can have:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">type Colors = &#x27;red&#x27; | &#x27;green&#x27; | &#x27;blue&#x27;;\n</code></pre></div>\n<p>Then, throughout our codebase, we can use the <code>Color</code> type to ensure functions can only be called with those values:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">addColor(name: Colors);\n</code></pre></div>\n<p>But, we may want to make sure that when we create a new possible value for the type, we don’t forget to use that value to do some initialization:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function initColors() {\n  addColor(&#x27;red&#x27;)\n  addColor(&#x27;green&#x27;);\n  addColor(&#x27;blue&#x27;);\n}\n</code></pre></div>\n<p>There are a few ways to do this, one would be to create a record that must contain every color:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">const allColors: Record&lt;Colors, boolean&gt; = {\n    red: true,\n    green: true,\n    blue: true,\n};\n\nfunction initColorsUsingRecord() {\n    (Object.keys(allColors) as Colors[]).forEach((color) =&gt; {\n        addColor(color);\n    });\n}\n</code></pre></div>\n<p>In the above snippet, we create a record that will have every <code>Colors</code> type as a key, and Typescript will complain when we add a new literal type to the <code>Colors</code> union and forget to add it to the record.</p>\n<p>Notice though that we end up just getting the list of keys in <code>allColors</code> as an array anyway, then casting that type to help with the type-hinting for <code>Object.keys</code>.</p>\n<p>We can also ensure that we create an array with every value of a given type:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Generator function to create functions that will throw typing exceptions when\n * the given array does not contain all values of the type\n */\nfunction ensureAllOf&lt;T&gt;() {\n    return &lt;U extends T[]&gt;(array: U &amp; ([T] extends [U[number]] ? unknown : &quot;Invalid&quot;)) =&gt; array;\n}\n\ntype Color = &#x27;red&#x27; | &#x27;green&#x27; | &#x27;blue&#x27;;\nconst ensureAllColors = ensureAllOf&lt;Color&gt;();\nconst colors = ensureAllColors([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]);\n\nfunction addColor(color: Color) {\n    // just a stub\n}\n\nfunction initColorsUsingEnsure() {\n    colors.forEach(color =&gt; {\n        addColor(color);\n    });\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/PQKhCgAIUhxBTAdvATgQwC4HsWQGYCuiAxhgJZaKTaTErybz5GkWIDO1AFppAO5kANoO4osfagE8ADmUQBzSPAAexeNPKVOfLkigwMuyPLIA3JJDQp0kyABMs8ToiwZalDGjmXhkU2kECJ0gsPG4mDBl4fWBwQhJNKiR2AnoAQWEAeTwAHgAVAD4ACgBKSABvKEhq+gxUqhyAVSVlDCQ7TjyAbQBdYqsbAC5IZoAySCKuvJ6WtsQOyC7GrsQCAFsAI1QemYB+SCIAaxc+KmGAIgBJRH9BMjtzkrKAXgLLazRJAG5wAF9wcCRaRMADCWEEOEgz0gAHJ6HYYZAAD6w+T0JCIlEwjaBeAwn7ELRuZKpeAZQRgiEoTjQknpLK5Sk4YolAlE9xUmlKDik8lM6mTOHwBEAGlR6MQMLF2NxMJ6rIB8VYlEsdjs-KKhKpw35ZUq1WqwGAkAAVgR2G40JALQQNn9FSxEpA5GQMPz2I12HJ5ABRHn0UoVKrVLU4dgAOjwOB9aGIXE14MhryDBtTqvViZQCapCtTvwVvyAA\">Typescript Playground</a></p>\n<p>In the above example, we have a template <code>ensureAllOf</code> that takes a type and spits out a function that takes an array of that type and will throw a typing error if that array does not contain all of the possible values.</p>\n<p>If we add “yellow” to the <code>Colors</code> type, then <code>ensureAllColors</code> will remind us that we need to add “yellow” to the list of values</p>\n<h2>Takeaway</h2>\n<p>While <code>ensureAllOf</code> may come in handy in some cases, it is almost always easier to use an enumeration:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">enum Color {\n    red = &#x27;red&#x27;,\n    green = &#x27;green&#x27;,\n    blue = &#x27;blue&#x27;\n}\n\nfunction addColor(color: Color) {\n    console.log(&#x27;init&#x27;, color);\n}\n\nconst colors = Object.values(Color);\n\nfunction initColorsUsingEnsure() {\n    colors.forEach(color =&gt; {\n        addColor(color);\n    });\n}\ninitColorsUsingEnsure();\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/KYOwrgtgBAwg9gGzgJygbwFBW1ZwAmUAvFAOR76kA0WOA5nqMWQ8KNbdgEYJjDOkefUhgC+GDADMwIAMYAXAJZwQUAIb588JMgAUsxCgBcsQ8gCU6TlAMgAzomAA6JHV2lFIRfOo2z5gG4xCVs7eT8dO2YAeS4AK2AFJwA3NV5gO11tFECJaTklFShPb2zkOwBVO086AFF7MDxdS0wcCJQ7J0kUWrVZAAt9M2IAPis2to0tMyGdXLbRXPES+TLK6pA6hqbAoA\">Typescript Playground</a></p>\n<p>Using an enumeration, there is no need to write a type and have to add the new value to the ensureOfAll array.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When creating more complex systems, there are times where you will want to ensure that an array contains every value of a defined type. We have a union of primitive literal types to define the possible values a type can have:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"type Colors = 'red' | 'green' | 'blue';\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, throughout our codebase, we can use the \", _jsx(_components.code, {\n        children: \"Color\"\n      }), \" type to ensure functions can only be called with those values:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"addColor(name: Colors);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But, we may want to make sure that when we create a new possible value for the type, we don’t forget to use that value to do some initialization:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function initColors() {\\n  addColor('red')\\n  addColor('green');\\n  addColor('blue');\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are a few ways to do this, one would be to create a record that must contain every color:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"const allColors: Record<Colors, boolean> = {\\n    red: true,\\n    green: true,\\n    blue: true,\\n};\\n\\nfunction initColorsUsingRecord() {\\n    (Object.keys(allColors) as Colors[]).forEach((color) => {\\n        addColor(color);\\n    });\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the above snippet, we create a record that will have every \", _jsx(_components.code, {\n        children: \"Colors\"\n      }), \" type as a key, and Typescript will complain when we add a new literal type to the \", _jsx(_components.code, {\n        children: \"Colors\"\n      }), \" union and forget to add it to the record.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Notice though that we end up just getting the list of keys in \", _jsx(_components.code, {\n        children: \"allColors\"\n      }), \" as an array anyway, then casting that type to help with the type-hinting for \", _jsx(_components.code, {\n        children: \"Object.keys\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can also ensure that we create an array with every value of a given type:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Generator function to create functions that will throw typing exceptions when\\n * the given array does not contain all values of the type\\n */\\nfunction ensureAllOf<T>() {\\n    return <U extends T[]>(array: U & ([T] extends [U[number]] ? unknown : \\\"Invalid\\\")) => array;\\n}\\n\\ntype Color = 'red' | 'green' | 'blue';\\nconst ensureAllColors = ensureAllOf<Color>();\\nconst colors = ensureAllColors(['red', 'green', 'blue']);\\n\\nfunction addColor(color: Color) {\\n    // just a stub\\n}\\n\\nfunction initColorsUsingEnsure() {\\n    colors.forEach(color => {\\n        addColor(color);\\n    });\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/PQKhCgAIUhxBTAdvATgQwC4HsWQGYCuiAxhgJZaKTaTErybz5GkWIDO1AFppAO5kANoO4osfagE8ADmUQBzSPAAexeNPKVOfLkigwMuyPLIA3JJDQp0kyABMs8ToiwZalDGjmXhkU2kECJ0gsPG4mDBl4fWBwQhJNKiR2AnoAQWEAeTwAHgAVAD4ACgBKSABvKEhq+gxUqhyAVSVlDCQ7TjyAbQBdYqsbAC5IZoAySCKuvJ6WtsQOyC7GrsQCAFsAI1QemYB+SCIAaxc+KmGAIgBJRH9BMjtzkrKAXgLLazRJAG5wAF9wcCRaRMADCWEEOEgz0gAHJ6HYYZAAD6w+T0JCIlEwjaBeAwn7ELRuZKpeAZQRgiEoTjQknpLK5Sk4YolAlE9xUmlKDik8lM6mTOHwBEAGlR6MQMLF2NxMJ6rIB8VYlEsdjs-KKhKpw35ZUq1WqwGAkAAVgR2G40JALQQNn9FSxEpA5GQMPz2I12HJ5ABRHn0UoVKrVLU4dgAOjwOB9aGIXE14MhryDBtTqvViZQCapCtTvwVvyAA\",\n        children: \"Typescript Playground\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the above example, we have a template \", _jsx(_components.code, {\n        children: \"ensureAllOf\"\n      }), \" that takes a type and spits out a function that takes an array of that type and will throw a typing error if that array does not contain all of the possible values.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we add “yellow” to the \", _jsx(_components.code, {\n        children: \"Colors\"\n      }), \" type, then \", _jsx(_components.code, {\n        children: \"ensureAllColors\"\n      }), \" will remind us that we need to add “yellow” to the list of values\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaway\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While \", _jsx(_components.code, {\n        children: \"ensureAllOf\"\n      }), \" may come in handy in some cases, it is almost always easier to use an enumeration:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"enum Color {\\n    red = 'red',\\n    green = 'green',\\n    blue = 'blue'\\n}\\n\\nfunction addColor(color: Color) {\\n    console.log('init', color);\\n}\\n\\nconst colors = Object.values(Color);\\n\\nfunction initColorsUsingEnsure() {\\n    colors.forEach(color => {\\n        addColor(color);\\n    });\\n}\\ninitColorsUsingEnsure();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/KYOwrgtgBAwg9gGzgJygbwFBW1ZwAmUAvFAOR76kA0WOA5nqMWQ8KNbdgEYJjDOkefUhgC+GDADMwIAMYAXAJZwQUAIb588JMgAUsxCgBcsQ8gCU6TlAMgAzomAA6JHV2lFIRfOo2z5gG4xCVs7eT8dO2YAeS4AK2AFJwA3NV5gO11tFECJaTklFShPb2zkOwBVO086AFF7MDxdS0wcCJQ7J0kUWrVZAAt9M2IAPis2to0tMyGdXLbRXPES+TLK6pA6hqbAoA\",\n        children: \"Typescript Playground\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using an enumeration, there is no need to write a type and have to add the new value to the ensureOfAll array.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen creating more complex systems, there are times where you will want to ensure that an array contains every value of a defined type. We have a union of primitive literal types to define the possible values a type can have:","excerptHTML":"<p>When creating more complex systems, there are times where you will want to ensure that an array contains every value of a defined type. We have a union of primitive literal types to define the possible values a type can have:</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"When creating more complex systems, there are times where you will want to ensure that an array contains every value of a defined type. We have a union of primitive literal types to define the possible values a type can have:\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},"previous":null,"next":{"slug":"2023-08-11-smart-contract-security","date":"2023-08-11","title":"Smart Contract Security","frontmatter":{"title":"Smart Contract Security"},"contentRaw":"\nThe crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\n\nIn general, the best practices around Smart Contracts are the same for writing secure code in general.\n\n## Keep it Simple\n\nKeep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.\n\n## Write Small Functions\n\nWrite small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.\n\n## Linting\n\nLint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.\n\n## Unit Tests\n\nUnit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called **negative** tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.\n\n## Scan for Security Vulnerabilities\n\nScan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.\n\nThere are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use [slither](https://github.com/crytic/slither):\n\n```tsx\nnpm install slither\nslither .\n```\n\nThis may take a while to run, but it will scan the compiles contracts for security issues.\n\n## Compliance\n\nFor Ethereum Smart Contracts, you can also use [slither](https://github.com/crytic/slither) to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.\n\n## Wrapping it Up\n\nSecurity is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.\n","contentHTML":"<p>The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.</p>\n<p>In general, the best practices around Smart Contracts are the same for writing secure code in general.</p>\n<h2>Keep it Simple</h2>\n<p>Keep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.</p>\n<h2>Write Small Functions</h2>\n<p>Write small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.</p>\n<h2>Linting</h2>\n<p>Lint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.</p>\n<h2>Unit Tests</h2>\n<p>Unit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called <strong>negative</strong> tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.</p>\n<h2>Scan for Security Vulnerabilities</h2>\n<p>Scan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.</p>\n<p>There are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use <a href=\"https://github.com/crytic/slither\">slither</a>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">npm install slither\nslither .\n</code></pre></div>\n<p>This may take a while to run, but it will scan the compiles contracts for security issues.</p>\n<h2>Compliance</h2>\n<p>For Ethereum Smart Contracts, you can also use <a href=\"https://github.com/crytic/slither\">slither</a> to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.</p>\n<h2>Wrapping it Up</h2>\n<p>Security is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    strong: \"strong\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In general, the best practices around Smart Contracts are the same for writing secure code in general.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Keep it Simple\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Keep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Write Small Functions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Write small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Linting\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Unit Tests\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Unit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called \", _jsx(_components.strong, {\n        children: \"negative\"\n      }), \" tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Scan for Security Vulnerabilities\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Scan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use \", _jsx(_components.a, {\n        href: \"https://github.com/crytic/slither\",\n        children: \"slither\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"npm install slither\\nslither .\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This may take a while to run, but it will scan the compiles contracts for security issues.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Compliance\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For Ethereum Smart Contracts, you can also use \", _jsx(_components.a, {\n        href: \"https://github.com/crytic/slither\",\n        children: \"slither\"\n      }), \" to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Wrapping it Up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Security is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThe crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.","excerptHTML":"<p>The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"}},"__N_SSG":true}