{"pageProps":{"headTitle":"Thoughts on Naming Utility Functions - idmontie's Portfolio","headKeywords":"programming","post":{"slug":"2025-11-22-naming-things","date":"2025-11-22","title":"Thoughts on Naming Utility Functions","frontmatter":{"title":"Thoughts on Naming Utility Functions","tags":["programming"]},"contentRaw":"\nWe all know that naming things is right up there in the top three most difficult things about programming, right next to concurrency and caching.\n\nFor common utility functions, I typically follow a few rules to at least prefix the function names in a consistent and meaningful way. Some of these are borrowed from React Testing Library, whose naming scheme I like very much as it is internally consistent with the return types that certain classes of functions return, but also easy to memorize how they behave.\n\n- `getFoo` - “get” as a utility function prefix name should indicate that the function will return `type Foo` and that it is meant to be synchronous and without side-effects. Typically a `getFoo` would always return Foo from the current context or in-memory synchronous data store.\n- `queryFoo` - functions with the prefix “query” should return `type Promise<Foo>`. Querying usually implies getting data asynchronously from an external data store and may have side-effects, let alone caching that data in a synchronous store for easier data-fetching in the future. I have also seen `fetchFoo` to indicate that the function will retrieve data from an external store, but I typically reserve `fetch` for low-level wrappers of the `fetch` utility.\n- `createFoo` - similar to `getXYZ`, this creates a local, synchronously made instance of `Foo`. There may be side-effects here, but typically this function is idempotent. Following the pattern of `typeOrm` , creating an instance of `Foo` is NOT the same as making an instance with nice defaults. This instance of `Foo` might not have any data initialized, but may only come with the instance methods and unset variables.\n- `mutateFoo` or `saveFoo` - create or update an instance of `type Foo`. Typically the only side-effect in these functions is storing the data in a cache, database, file, etc.\n- `makeFoo` - this is very similar to `createFoo`, but this is typically reserved for mocks and default versions of `Foo`. For example, if you have a form with a lot of presets that a user is filling out, you might have a default version of the `Foo` object that you want to represent in your view state. When you extract that default, it would be returned in a `makeFoo` function (that might call `createFoo` in its internals to make an instance of `Foo`). Likewise, for mocks, you may want to make the process of creating a mock with a bunch of defaults simple, and have a function named `createMockFoo` with signature: `createMockFoo(overrides?: Partial<Foo>): Foo`.\n\nThis is by no means an exhaustive list, but I do find it helpful to follow this pattern for code consistency and setting expectations with other software developers. If I write a function called `getFoo`, it shouldn’t query a database. If I write a `makeFoo` function, I would expect a nicely initialized `Foo` to pop out.\n\nTo me, following these conventions is similar to legalistic words like “must” and “can”. If we were to use these words in programming conventions, then `mustXYZ` would mean a function will ALWAYS return a value, no matter what, while `canXYZ` would mean the function could return `null | undefined` as well. Similarly, having some standard naming convention helps teams write code that others will understand without having to read jsdocs or dive deeper into the code every single time.\n","contentHTML":"<p>We all know that naming things is right up there in the top three most difficult things about programming, right next to concurrency and caching.</p>\n<p>For common utility functions, I typically follow a few rules to at least prefix the function names in a consistent and meaningful way. Some of these are borrowed from React Testing Library, whose naming scheme I like very much as it is internally consistent with the return types that certain classes of functions return, but also easy to memorize how they behave.</p>\n<ul>\n<li><code>getFoo</code> - “get” as a utility function prefix name should indicate that the function will return <code>type Foo</code> and that it is meant to be synchronous and without side-effects. Typically a <code>getFoo</code> would always return Foo from the current context or in-memory synchronous data store.</li>\n<li><code>queryFoo</code> - functions with the prefix “query” should return <code>type Promise&lt;Foo&gt;</code>. Querying usually implies getting data asynchronously from an external data store and may have side-effects, let alone caching that data in a synchronous store for easier data-fetching in the future. I have also seen <code>fetchFoo</code> to indicate that the function will retrieve data from an external store, but I typically reserve <code>fetch</code> for low-level wrappers of the <code>fetch</code> utility.</li>\n<li><code>createFoo</code> - similar to <code>getXYZ</code>, this creates a local, synchronously made instance of <code>Foo</code>. There may be side-effects here, but typically this function is idempotent. Following the pattern of <code>typeOrm</code> , creating an instance of <code>Foo</code> is NOT the same as making an instance with nice defaults. This instance of <code>Foo</code> might not have any data initialized, but may only come with the instance methods and unset variables.</li>\n<li><code>mutateFoo</code> or <code>saveFoo</code> - create or update an instance of <code>type Foo</code>. Typically the only side-effect in these functions is storing the data in a cache, database, file, etc.</li>\n<li><code>makeFoo</code> - this is very similar to <code>createFoo</code>, but this is typically reserved for mocks and default versions of <code>Foo</code>. For example, if you have a form with a lot of presets that a user is filling out, you might have a default version of the <code>Foo</code> object that you want to represent in your view state. When you extract that default, it would be returned in a <code>makeFoo</code> function (that might call <code>createFoo</code> in its internals to make an instance of <code>Foo</code>). Likewise, for mocks, you may want to make the process of creating a mock with a bunch of defaults simple, and have a function named <code>createMockFoo</code> with signature: <code>createMockFoo(overrides?: Partial&lt;Foo&gt;): Foo</code>.</li>\n</ul>\n<p>This is by no means an exhaustive list, but I do find it helpful to follow this pattern for code consistency and setting expectations with other software developers. If I write a function called <code>getFoo</code>, it shouldn’t query a database. If I write a <code>makeFoo</code> function, I would expect a nicely initialized <code>Foo</code> to pop out.</p>\n<p>To me, following these conventions is similar to legalistic words like “must” and “can”. If we were to use these words in programming conventions, then <code>mustXYZ</code> would mean a function will ALWAYS return a value, no matter what, while <code>canXYZ</code> would mean the function could return <code>null | undefined</code> as well. Similarly, having some standard naming convention helps teams write code that others will understand without having to read jsdocs or dive deeper into the code every single time.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"We all know that naming things is right up there in the top three most difficult things about programming, right next to concurrency and caching.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For common utility functions, I typically follow a few rules to at least prefix the function names in a consistent and meaningful way. Some of these are borrowed from React Testing Library, whose naming scheme I like very much as it is internally consistent with the return types that certain classes of functions return, but also easy to memorize how they behave.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"getFoo\"\n        }), \" - “get” as a utility function prefix name should indicate that the function will return \", _jsx(_components.code, {\n          children: \"type Foo\"\n        }), \" and that it is meant to be synchronous and without side-effects. Typically a \", _jsx(_components.code, {\n          children: \"getFoo\"\n        }), \" would always return Foo from the current context or in-memory synchronous data store.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"queryFoo\"\n        }), \" - functions with the prefix “query” should return \", _jsx(_components.code, {\n          children: \"type Promise<Foo>\"\n        }), \". Querying usually implies getting data asynchronously from an external data store and may have side-effects, let alone caching that data in a synchronous store for easier data-fetching in the future. I have also seen \", _jsx(_components.code, {\n          children: \"fetchFoo\"\n        }), \" to indicate that the function will retrieve data from an external store, but I typically reserve \", _jsx(_components.code, {\n          children: \"fetch\"\n        }), \" for low-level wrappers of the \", _jsx(_components.code, {\n          children: \"fetch\"\n        }), \" utility.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"createFoo\"\n        }), \" - similar to \", _jsx(_components.code, {\n          children: \"getXYZ\"\n        }), \", this creates a local, synchronously made instance of \", _jsx(_components.code, {\n          children: \"Foo\"\n        }), \". There may be side-effects here, but typically this function is idempotent. Following the pattern of \", _jsx(_components.code, {\n          children: \"typeOrm\"\n        }), \" , creating an instance of \", _jsx(_components.code, {\n          children: \"Foo\"\n        }), \" is NOT the same as making an instance with nice defaults. This instance of \", _jsx(_components.code, {\n          children: \"Foo\"\n        }), \" might not have any data initialized, but may only come with the instance methods and unset variables.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"mutateFoo\"\n        }), \" or \", _jsx(_components.code, {\n          children: \"saveFoo\"\n        }), \" - create or update an instance of \", _jsx(_components.code, {\n          children: \"type Foo\"\n        }), \". Typically the only side-effect in these functions is storing the data in a cache, database, file, etc.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"makeFoo\"\n        }), \" - this is very similar to \", _jsx(_components.code, {\n          children: \"createFoo\"\n        }), \", but this is typically reserved for mocks and default versions of \", _jsx(_components.code, {\n          children: \"Foo\"\n        }), \". For example, if you have a form with a lot of presets that a user is filling out, you might have a default version of the \", _jsx(_components.code, {\n          children: \"Foo\"\n        }), \" object that you want to represent in your view state. When you extract that default, it would be returned in a \", _jsx(_components.code, {\n          children: \"makeFoo\"\n        }), \" function (that might call \", _jsx(_components.code, {\n          children: \"createFoo\"\n        }), \" in its internals to make an instance of \", _jsx(_components.code, {\n          children: \"Foo\"\n        }), \"). Likewise, for mocks, you may want to make the process of creating a mock with a bunch of defaults simple, and have a function named \", _jsx(_components.code, {\n          children: \"createMockFoo\"\n        }), \" with signature: \", _jsx(_components.code, {\n          children: \"createMockFoo(overrides?: Partial<Foo>): Foo\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is by no means an exhaustive list, but I do find it helpful to follow this pattern for code consistency and setting expectations with other software developers. If I write a function called \", _jsx(_components.code, {\n        children: \"getFoo\"\n      }), \", it shouldn’t query a database. If I write a \", _jsx(_components.code, {\n        children: \"makeFoo\"\n      }), \" function, I would expect a nicely initialized \", _jsx(_components.code, {\n        children: \"Foo\"\n      }), \" to pop out.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To me, following these conventions is similar to legalistic words like “must” and “can”. If we were to use these words in programming conventions, then \", _jsx(_components.code, {\n        children: \"mustXYZ\"\n      }), \" would mean a function will ALWAYS return a value, no matter what, while \", _jsx(_components.code, {\n        children: \"canXYZ\"\n      }), \" would mean the function could return \", _jsx(_components.code, {\n        children: \"null | undefined\"\n      }), \" as well. Similarly, having some standard naming convention helps teams write code that others will understand without having to read jsdocs or dive deeper into the code every single time.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWe all know that naming things is right up there in the top three most difficult things about programming, right next to concurrency and caching.","excerptHTML":"<p>We all know that naming things is right up there in the top three most difficult things about programming, right next to concurrency and caching.</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"We all know that naming things is right up there in the top three most difficult things about programming, right next to concurrency and caching.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["programming"]},"previous":{"slug":"2025-12-07-spreading-type-holes","title":"Forbidden Typescript: Spreading Type-holes"},"next":{"slug":"2025-06-16-gpus-best-buy-queues","title":"GPUs and Best Buy Queues"}},"__N_SSG":true}