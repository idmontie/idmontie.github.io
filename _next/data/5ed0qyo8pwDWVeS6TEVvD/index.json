{"pageProps":{"posts":[{"slug":"2023-08-10-get-class","date":"2023-08-10","title":"Forbidden Typescript: Get Class Name","frontmatter":{"title":"Forbidden Typescript: Get Class Name"},"contentRaw":"\nWe don’t get a lot of information using `typeof` in JavaScript or TypeScript. At most, it tells us whether a value is `undefined`, `number`, `string`, or `object`. If you want to get the class name using a function, you can use the following extended version of `classOf` that is originally from “JavaScript: The Definitive Guide”:\n\n```tsx\nfunction classOf(obj: unknown) {\n    if (obj === null) return \"Null\";\n    if (typeof obj === \"undefined\") return \"Undefined\";\n\n    if (typeof obj === 'object') {\n        // Warning: this won't work if your Typescript is minified and class names are mangled.\n        return (obj as object).constructor.name;\n    }\n\n    if (typeof obj === 'function') {\n        // Warning: this won't work if your Typescript is minified and function names are mangled.\n        const possibleName = (obj as CallableFunction).name;\n        if (possibleName) {\n            return possibleName;\n        }\n    }\n\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\n\nconsole.log(classOf(null)); // \"Null\"\nconsole.log(classOf(undefined)); // \"Undefined\"\nconsole.log(classOf(1)); // \"Number\"\nconsole.log(classOf(\"foobar\")); // \"String\"\nconsole.log(classOf({})); // \"Object\"\nconsole.log(classOf([])); // \"Array\"\nconsole.log(classOf(new Date()))\n\nclass Test {}\nconsole.log(classOf(new Test())); // \"Test\"\n\nfunction test() {}\nconsole.log(classOf(test)); // \"test\"\n\nconsole.log(classOf(function () {})) // \"Function\"\n```\n\n[Playground Link](https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA)\n\nThis `classOf` function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.\n\n## Takeaways\n\nUnfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead `instanceof` should be used, or a static name attribute that cannot be modified.\n","contentHTML":"<p>We don’t get a lot of information using <code>typeof</code> in JavaScript or TypeScript. At most, it tells us whether a value is <code>undefined</code>, <code>number</code>, <code>string</code>, or <code>object</code>. If you want to get the class name using a function, you can use the following extended version of <code>classOf</code> that is originally from “JavaScript: The Definitive Guide”:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function classOf(obj: unknown) {\n    if (obj === null) return &quot;Null&quot;;\n    if (typeof obj === &quot;undefined&quot;) return &quot;Undefined&quot;;\n\n    if (typeof obj === &#x27;object&#x27;) {\n        // Warning: this won&#x27;t work if your Typescript is minified and class names are mangled.\n        return (obj as object).constructor.name;\n    }\n\n    if (typeof obj === &#x27;function&#x27;) {\n        // Warning: this won&#x27;t work if your Typescript is minified and function names are mangled.\n        const possibleName = (obj as CallableFunction).name;\n        if (possibleName) {\n            return possibleName;\n        }\n    }\n\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\n\nconsole.log(classOf(null)); // &quot;Null&quot;\nconsole.log(classOf(undefined)); // &quot;Undefined&quot;\nconsole.log(classOf(1)); // &quot;Number&quot;\nconsole.log(classOf(&quot;foobar&quot;)); // &quot;String&quot;\nconsole.log(classOf({})); // &quot;Object&quot;\nconsole.log(classOf([])); // &quot;Array&quot;\nconsole.log(classOf(new Date()))\n\nclass Test {}\nconsole.log(classOf(new Test())); // &quot;Test&quot;\n\nfunction test() {}\nconsole.log(classOf(test)); // &quot;test&quot;\n\nconsole.log(classOf(function () {})) // &quot;Function&quot;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA\">Playground Link</a></p>\n<p>This <code>classOf</code> function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.</p>\n<h2>Takeaways</h2>\n<p>Unfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead <code>instanceof</code> should be used, or a static name attribute that cannot be modified.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"We don’t get a lot of information using \", _jsx(_components.code, {\n        children: \"typeof\"\n      }), \" in JavaScript or TypeScript. At most, it tells us whether a value is \", _jsx(_components.code, {\n        children: \"undefined\"\n      }), \", \", _jsx(_components.code, {\n        children: \"number\"\n      }), \", \", _jsx(_components.code, {\n        children: \"string\"\n      }), \", or \", _jsx(_components.code, {\n        children: \"object\"\n      }), \". If you want to get the class name using a function, you can use the following extended version of \", _jsx(_components.code, {\n        children: \"classOf\"\n      }), \" that is originally from “JavaScript: The Definitive Guide”:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function classOf(obj: unknown) {\\n    if (obj === null) return \\\"Null\\\";\\n    if (typeof obj === \\\"undefined\\\") return \\\"Undefined\\\";\\n\\n    if (typeof obj === 'object') {\\n        // Warning: this won't work if your Typescript is minified and class names are mangled.\\n        return (obj as object).constructor.name;\\n    }\\n\\n    if (typeof obj === 'function') {\\n        // Warning: this won't work if your Typescript is minified and function names are mangled.\\n        const possibleName = (obj as CallableFunction).name;\\n        if (possibleName) {\\n            return possibleName;\\n        }\\n    }\\n\\n    return Object.prototype.toString.call(obj).slice(8, -1);\\n}\\n\\nconsole.log(classOf(null)); // \\\"Null\\\"\\nconsole.log(classOf(undefined)); // \\\"Undefined\\\"\\nconsole.log(classOf(1)); // \\\"Number\\\"\\nconsole.log(classOf(\\\"foobar\\\")); // \\\"String\\\"\\nconsole.log(classOf({})); // \\\"Object\\\"\\nconsole.log(classOf([])); // \\\"Array\\\"\\nconsole.log(classOf(new Date()))\\n\\nclass Test {}\\nconsole.log(classOf(new Test())); // \\\"Test\\\"\\n\\nfunction test() {}\\nconsole.log(classOf(test)); // \\\"test\\\"\\n\\nconsole.log(classOf(function () {})) // \\\"Function\\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBANgQwM4YPLABRwBGAVgFyLgDWYcA7mAJSIDeAUIh4jMIgSYgF4hiMCBQomAJwCmUEJKQAiAHJiUigNztO3XlACeAB2lweRYoOGLwAE2nAYYaTcVTZ8pQFUwdh05da2hy6eAbGpojmlgKIAOTm0tCxTGycaYgA9BmIAOpoCo4A5uRQABYwGIi0CLFQVXCSlFw8+nDyiAAqRtIYEJIwhnUViAC2jtwwzohoPsjoWCJoIz3TMqMzhSjOAHRB6TJyCrxRmJEkiVAM2xAIGFCSINAN22BL0lppAL6seyFhJmZ+EIYrFQJBYDUUns0llcvkwEUSuVKtUwLV6o1mohWu0usZev1BlxKmMEQ4pjMbIgwdB4EhXstKvlpOswJsdtDODcwHdEIY4FgYIQtso3oJjvxTgBhNDiNDC6QAMXAtIQVwZ705wR4eH5goVouWUPSJsQBw8fIFGCFIreH1N3y+PzS5qO2HO0G2hkkcCgvu62z9AGV7kVrrKUHxiFcMCgYBBpHgABwAGkQAFoAIwMLTfVjcjBwLbbFBwQp4VCYHD4UTiBg5zLZFRqRT525F6QlssV+bVvC2eyOZz1jSNxCKby+IcuNs8jtd8uVrC4PDZhuw5sjQjSSStgvz0uL3srxTAOBEfKuddNkP9Nl79vFw89qsr5ifEdjxTu4gXB9zp9uyXPsAG0AF1Pw3ABBSRJDQfR-0LQCj1fGtpFoRAABE0CgRN6wYH5gM6Ho6nfWckM7Z9gJXJwMI6Ei8Hw0cN3ou5W1YGkISQXC7kYlhvn3ZCX2XfAeMua9xzE9jBMooDj3wTi6V4FIPyYDdlXBOlFCAA\",\n        children: \"Playground Link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This \", _jsx(_components.code, {\n        children: \"classOf\"\n      }), \" function works for any value, including numbers, strings, booleans, classes, and functions. It will return the best name for that given value that is passed. If the object has a constructor name, that value will be returned. If that value is a function, the name of that function will be returned.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaways\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Unfortunately, during some transpilation steps or code compression, these names get mangled or removed completely, so it’s best not to rely on the class’s actual name directly. Instead \", _jsx(_components.code, {\n        children: \"instanceof\"\n      }), \" should be used, or a static name attribute that cannot be modified.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWe don’t get a lot of information using `typeof` in JavaScript or TypeScript. At most, it tells us whether a value is `undefined`, `number`, `string`, or `object`. If you want to get the class name using a function, you can use the following extended version of `classOf` that is originally from “JavaScript: The Definitive Guide”:","excerptHTML":"<p>We don’t get a lot of information using <code>typeof</code> in JavaScript or TypeScript. At most, it tells us whether a value is <code>undefined</code>, <code>number</code>, <code>string</code>, or <code>object</code>. If you want to get the class name using a function, you can use the following extended version of <code>classOf</code> that is originally from “JavaScript: The Definitive Guide”:</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_components.p, {\n    children: [\"We don’t get a lot of information using \", _jsx(_components.code, {\n      children: \"typeof\"\n    }), \" in JavaScript or TypeScript. At most, it tells us whether a value is \", _jsx(_components.code, {\n      children: \"undefined\"\n    }), \", \", _jsx(_components.code, {\n      children: \"number\"\n    }), \", \", _jsx(_components.code, {\n      children: \"string\"\n    }), \", or \", _jsx(_components.code, {\n      children: \"object\"\n    }), \". If you want to get the class name using a function, you can use the following extended version of \", _jsx(_components.code, {\n      children: \"classOf\"\n    }), \" that is originally from “JavaScript: The Definitive Guide”:\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"slug":"2023-08-09-enumerating-properties","date":"2023-08-09","title":"Forbidden Typescript: Enumerating Properties","frontmatter":{"title":"Forbidden Typescript: Enumerating Properties"},"contentRaw":"\nIn [“JavaScript: The Definitive Guide”](https://amzn.to/3rV5Xov), there are functions described in **6.5 Enumerating Properties** that probably shouldn’t be used in production code because they modify their input parameters: `extend`, `merge`, `restrict`, and `subtract`.\n\nLet’s re-create each one using more modern practices in Typescript that don’t modify the input parameters:\n\n```tsx\n/**\n * Create a new object that returns the properties of target, overwritten with the properties in props\n */\nfunction extend<T extends object, P extends object>(target: T, props: P): T & P {\n    return {...target, ...props};\n}\n```\n\nEven in a more modern implementation, I would never recommend this. It is almost always easier to write `{...a, ...b}` inline and have its meaning be more clear.\n\nNext we have merge, not to be confused with extend:\n\n```tsx\n/**\n * Create a new object that returns all the properties of target and props, but the properties\n * in target are left alone.\n */\nfunction merge<T extends object, P extends object>(target: T, props: P): T & P {\n    return {...props, ...target};\n}\n```\n\nSame thing here, even with a more type-safe implementation, it’s almost always more clear to have an inline spread of `{...b, ...a}`.\n\nA more interesting function implementation is `restrict`:\n\n```tsx\n/**\n * Create a new object that returns all the values in target that also exist in props.\n */\nfunction restrict<P extends object, T extends P>(target: T, props: P): Pick<T, keyof P> {\n    const t: Partial<T> = { ...target };\n\n    for (let key in target) {\n        if (!(key in props)) {\n            delete t[key];\n        }\n    }\n\n    return t as Pick<T, keyof P>;\n}\n\nconst obj1 = { a: 123, b: 222 };\nconst obj2 = { b: 0 };\n\nconsole.log(restrict(obj1, obj2)); // { b: 222 }\n```\n\nHere we end up cloning our target object in order to delete keys from it later. An alternative approach might be to only construct the object with keys in props in the first place. This implementation is at least type-safe and will give you the correct typings for the object returned from `restrict`.\n\nLastly, here is our type-safe version of `subtract`:\n\n```tsx\n/**\n * Create a new object that returns all the values in target that do not exist in props.\n */\nfunction subtract<T extends object, P extends object>(target: T, props: P): Omit<T, keyof P> {\n    const t: Partial<T> = { ...target };\n\n    for (let key in props) {\n        if (key in t) {\n            delete t[key as unknown as keyof T];\n        }\n    }\n\n    return t as Omit<T, keyof P>;\n}\n\nconsole.log(subtract(obj1, obj2)); // { a: 123 }\n```\n\nBoth the `restrict` and `subtract` make use of type assertions to tell the compiler we know the actual types of the objects and keys when we are removing keys. Without these assertions, `t` is still a `Partial<T>`, even after we delete the keys from the object.\n\n## Takeaway\n\nIt’s almost always more clear and more type-safe to merge objects using inline spread notation than trying to use a clever utility. There are cases though, like `restrict` and `subtract` where we can leverage the type system to write safer code. There is always a balance to find when trying to write utilities between making something easier for engineers, and adding additional compile time safety.\n","contentHTML":"<p>In <a href=\"https://amzn.to/3rV5Xov\">“JavaScript: The Definitive Guide”</a>, there are functions described in <strong>6.5 Enumerating Properties</strong> that probably shouldn’t be used in production code because they modify their input parameters: <code>extend</code>, <code>merge</code>, <code>restrict</code>, and <code>subtract</code>.</p>\n<p>Let’s re-create each one using more modern practices in Typescript that don’t modify the input parameters:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns the properties of target, overwritten with the properties in props\n */\nfunction extend&lt;T extends object, P extends object&gt;(target: T, props: P): T &amp; P {\n    return {...target, ...props};\n}\n</code></pre></div>\n<p>Even in a more modern implementation, I would never recommend this. It is almost always easier to write <code>{...a, ...b}</code> inline and have its meaning be more clear.</p>\n<p>Next we have merge, not to be confused with extend:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns all the properties of target and props, but the properties\n * in target are left alone.\n */\nfunction merge&lt;T extends object, P extends object&gt;(target: T, props: P): T &amp; P {\n    return {...props, ...target};\n}\n</code></pre></div>\n<p>Same thing here, even with a more type-safe implementation, it’s almost always more clear to have an inline spread of <code>{...b, ...a}</code>.</p>\n<p>A more interesting function implementation is <code>restrict</code>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns all the values in target that also exist in props.\n */\nfunction restrict&lt;P extends object, T extends P&gt;(target: T, props: P): Pick&lt;T, keyof P&gt; {\n    const t: Partial&lt;T&gt; = { ...target };\n\n    for (let key in target) {\n        if (!(key in props)) {\n            delete t[key];\n        }\n    }\n\n    return t as Pick&lt;T, keyof P&gt;;\n}\n\nconst obj1 = { a: 123, b: 222 };\nconst obj2 = { b: 0 };\n\nconsole.log(restrict(obj1, obj2)); // { b: 222 }\n</code></pre></div>\n<p>Here we end up cloning our target object in order to delete keys from it later. An alternative approach might be to only construct the object with keys in props in the first place. This implementation is at least type-safe and will give you the correct typings for the object returned from <code>restrict</code>.</p>\n<p>Lastly, here is our type-safe version of <code>subtract</code>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * Create a new object that returns all the values in target that do not exist in props.\n */\nfunction subtract&lt;T extends object, P extends object&gt;(target: T, props: P): Omit&lt;T, keyof P&gt; {\n    const t: Partial&lt;T&gt; = { ...target };\n\n    for (let key in props) {\n        if (key in t) {\n            delete t[key as unknown as keyof T];\n        }\n    }\n\n    return t as Omit&lt;T, keyof P&gt;;\n}\n\nconsole.log(subtract(obj1, obj2)); // { a: 123 }\n</code></pre></div>\n<p>Both the <code>restrict</code> and <code>subtract</code> make use of type assertions to tell the compiler we know the actual types of the objects and keys when we are removing keys. Without these assertions, <code>t</code> is still a <code>Partial&lt;T&gt;</code>, even after we delete the keys from the object.</p>\n<h2>Takeaway</h2>\n<p>It’s almost always more clear and more type-safe to merge objects using inline spread notation than trying to use a clever utility. There are cases though, like <code>restrict</code> and <code>subtract</code> where we can leverage the type system to write safer code. There is always a balance to find when trying to write utilities between making something easier for engineers, and adding additional compile time safety.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    code: \"code\",\n    pre: \"pre\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.a, {\n        href: \"https://amzn.to/3rV5Xov\",\n        children: \"“JavaScript: The Definitive Guide”\"\n      }), \", there are functions described in \", _jsx(_components.strong, {\n        children: \"6.5 Enumerating Properties\"\n      }), \" that probably shouldn’t be used in production code because they modify their input parameters: \", _jsx(_components.code, {\n        children: \"extend\"\n      }), \", \", _jsx(_components.code, {\n        children: \"merge\"\n      }), \", \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s re-create each one using more modern practices in Typescript that don’t modify the input parameters:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns the properties of target, overwritten with the properties in props\\n */\\nfunction extend<T extends object, P extends object>(target: T, props: P): T & P {\\n    return {...target, ...props};\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Even in a more modern implementation, I would never recommend this. It is almost always easier to write \", _jsx(_components.code, {\n        children: \"{...a, ...b}\"\n      }), \" inline and have its meaning be more clear.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next we have merge, not to be confused with extend:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns all the properties of target and props, but the properties\\n * in target are left alone.\\n */\\nfunction merge<T extends object, P extends object>(target: T, props: P): T & P {\\n    return {...props, ...target};\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Same thing here, even with a more type-safe implementation, it’s almost always more clear to have an inline spread of \", _jsx(_components.code, {\n        children: \"{...b, ...a}\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A more interesting function implementation is \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns all the values in target that also exist in props.\\n */\\nfunction restrict<P extends object, T extends P>(target: T, props: P): Pick<T, keyof P> {\\n    const t: Partial<T> = { ...target };\\n\\n    for (let key in target) {\\n        if (!(key in props)) {\\n            delete t[key];\\n        }\\n    }\\n\\n    return t as Pick<T, keyof P>;\\n}\\n\\nconst obj1 = { a: 123, b: 222 };\\nconst obj2 = { b: 0 };\\n\\nconsole.log(restrict(obj1, obj2)); // { b: 222 }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we end up cloning our target object in order to delete keys from it later. An alternative approach might be to only construct the object with keys in props in the first place. This implementation is at least type-safe and will give you the correct typings for the object returned from \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Lastly, here is our type-safe version of \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * Create a new object that returns all the values in target that do not exist in props.\\n */\\nfunction subtract<T extends object, P extends object>(target: T, props: P): Omit<T, keyof P> {\\n    const t: Partial<T> = { ...target };\\n\\n    for (let key in props) {\\n        if (key in t) {\\n            delete t[key as unknown as keyof T];\\n        }\\n    }\\n\\n    return t as Omit<T, keyof P>;\\n}\\n\\nconsole.log(subtract(obj1, obj2)); // { a: 123 }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Both the \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \" make use of type assertions to tell the compiler we know the actual types of the objects and keys when we are removing keys. Without these assertions, \", _jsx(_components.code, {\n        children: \"t\"\n      }), \" is still a \", _jsx(_components.code, {\n        children: \"Partial<T>\"\n      }), \", even after we delete the keys from the object.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaway\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It’s almost always more clear and more type-safe to merge objects using inline spread notation than trying to use a clever utility. There are cases though, like \", _jsx(_components.code, {\n        children: \"restrict\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"subtract\"\n      }), \" where we can leverage the type system to write safer code. There is always a balance to find when trying to write utilities between making something easier for engineers, and adding additional compile time safety.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nIn [“JavaScript: The Definitive Guide”](https://amzn.to/3rV5Xov), there are functions described in **6.5 Enumerating Properties** that probably shouldn’t be used in production code because they modify their input parameters: `extend`, `merge`, `restrict`, and `subtract`.","excerptHTML":"<p>In <a href=\"https://amzn.to/3rV5Xov\">“JavaScript: The Definitive Guide”</a>, there are functions described in <strong>6.5 Enumerating Properties</strong> that probably shouldn’t be used in production code because they modify their input parameters: <code>extend</code>, <code>merge</code>, <code>restrict</code>, and <code>subtract</code>.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_components.p, {\n    children: [\"In \", _jsx(_components.a, {\n      href: \"https://amzn.to/3rV5Xov\",\n      children: \"“JavaScript: The Definitive Guide”\"\n    }), \", there are functions described in \", _jsx(_components.strong, {\n      children: \"6.5 Enumerating Properties\"\n    }), \" that probably shouldn’t be used in production code because they modify their input parameters: \", _jsx(_components.code, {\n      children: \"extend\"\n    }), \", \", _jsx(_components.code, {\n      children: \"merge\"\n    }), \", \", _jsx(_components.code, {\n      children: \"restrict\"\n    }), \", and \", _jsx(_components.code, {\n      children: \"subtract\"\n    }), \".\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"}],"projects":[{"slug":"2023-08-07-wax-cpp-tutorial","date":"2023-08-07","title":"WAX C++ NFT Tutorial","frontmatter":{"title":"WAX C++ NFT Tutorial","image":"/images/project-wax.jpg","description":"WAX smart contract development course that guides developers through the process of creating a non-fungible token (NFT) smart contract.\n","language_tags":["node","cpp"],"framework_tags":["wax","blockchain","nfts"],"view_link":"https://dev.to/idmontie/series/23860","github_link":"https://github.com/CapsuleCat/wax-nft-tutorial"},"contentRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\n\nIt is a great introduction to WAX smart contract development and the WAX ecosystem.\n","contentHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.</p>\n<p>It is a great introduction to WAX smart contract development and the WAX ecosystem.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"This is a 22 part series on DevTo that goes through the entire process of creating\\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is a great introduction to WAX smart contract development and the WAX ecosystem.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating","excerptHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"This is a 22 part series on DevTo that goes through the entire process of creating\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"slug":"2023-08-04-lacework","date":"2023-08-04","title":"Lacework","frontmatter":{"title":"Lacework","image":"/images/project-lacework.png","description":"Cloud security monitoring at scale.\n","language_tags":["node","javascript","typescript","java"],"github_link":"https://github.com/lacework"},"contentRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\n","contentHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.","excerptHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"}]},"__N_SSG":true}