{"pageProps":{"headTitle":"Feature Contexts - idmontie's Portfolio","headKeywords":"typescript, react","post":{"slug":"2023-08-17-feature-context","date":"2023-08-17","title":"Feature Contexts","frontmatter":{"title":"Feature Contexts","tags":["typescript","react"]},"contentRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).\n\n## Simple Example\n\nAs requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\n\n```tsx\n<button data-track=\"chat.form.send\">Send<button>\n```\n\nAnd as the tracking grows, these might get moved to a separate file and a constant/enumeration:\n\n```tsx\nconst ChatTracking = {\n  send: 'chat.form.send',\n  attachMedia: 'chat.form.attachMedia',\n  edit: 'chat.messages.edit',\n  delete: 'chat.messages.delete',\n} as const;\n\n// usage\n\n<button data-track={ChatTracking.send}>Send</button>\n```\n\nWe have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn't end up reducing any of the duplication.\n\n## Passing Namespaces\n\nAs the application grows more complex, an engineer working on another set of features ends up wanting to reuse the chat form from above. It already has some additional animation and composes the component library widgets, why not reuse it in the context of forums.\n\nExcept now the `data-track` attribute has to be passed in as a prop:\n\n```mermaid\ngraph TD\n  Forums --> ChatForm\n  Chat --> ChatForm\n  ChatForm --> SendButton\n  SendButton --> Button\n\n```\n\nThe Forums usage ends up adding its own tracking attribute, but ends up having to prop drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\n\n## Using Context\n\nInstead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\n\nFirst let's build a context in React:\n\n**FeatureContext.tsx**\n\n```tsx\nimport { createContext } from 'react';\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext<string[]>([]);\n```\n\nThen we'll create a helper component that we can use throughout the application:\n\n**Feature.tsx**\n\n```tsx\nimport type { ReactNode } from 'react';\nimport { useContext, useMemo } from 'react';\nimport { FeatureContext } from './FeatureContext';\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() => {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        <FeatureContext.Provider value={currentContext}>\n            {children}\n        </FeatureContext.Provider>\n    );\n}\n```\n\nUsage of this component would look like:\n\n```tsx\nfunction Forums() {\n  return (\n    <Feature name=\"forums\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction Chat() {\n  return (\n    <Feature name=\"chat\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction ChatForm() {\n  return (\n    <Feature name=\"form\">\n      <SendButton />\n    </Feature>\n  );\n}\n\n```\n\nThen, in SendButton, when we actually need to use the feature context, we construct the namespace:\n\n**SendButton.tsx**\n\n```tsx\nfunction SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\n  );\n}\n```\n\nNote: the above example has been simplified for this article's sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\n\nNo additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\n\n## Conclusion\n\nRather than trying to alleviate string duplication and prop drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop drilling the namespace down to every component.\n","contentHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>\n<h2>Simple Example</h2>\n<p>As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">&lt;button data-track=&quot;chat.form.send&quot;&gt;Send&lt;button&gt;\n</code></pre></div>\n<p>And as the tracking grows, these might get moved to a separate file and a constant/enumeration:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">const ChatTracking = {\n  send: &#x27;chat.form.send&#x27;,\n  attachMedia: &#x27;chat.form.attachMedia&#x27;,\n  edit: &#x27;chat.messages.edit&#x27;,\n  delete: &#x27;chat.messages.delete&#x27;,\n} as const;\n\n// usage\n\n&lt;button data-track={ChatTracking.send}&gt;Send&lt;/button&gt;\n</code></pre></div>\n<p>We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn&#x27;t end up reducing any of the duplication.</p>\n<h2>Passing Namespaces</h2>\n<p>As the application grows more complex, an engineer working on another set of features ends up wanting to reuse the chat form from above. It already has some additional animation and composes the component library widgets, why not reuse it in the context of forums.</p>\n<p>Except now the <code>data-track</code> attribute has to be passed in as a prop:</p>\n<mermaid chart=\"graph TD\n  Forums --&gt; ChatForm\n  Chat --&gt; ChatForm\n  ChatForm --&gt; SendButton\n  SendButton --&gt; Button\n\"></mermaid>\n<p>The Forums usage ends up adding its own tracking attribute, but ends up having to prop drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.</p>\n<h2>Using Context</h2>\n<p>Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.</p>\n<p>First let&#x27;s build a context in React:</p>\n<p><strong>FeatureContext.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { createContext } from &#x27;react&#x27;;\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext&lt;string[]&gt;([]);\n</code></pre></div>\n<p>Then we&#x27;ll create a helper component that we can use throughout the application:</p>\n<p><strong>Feature.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import type { ReactNode } from &#x27;react&#x27;;\nimport { useContext, useMemo } from &#x27;react&#x27;;\nimport { FeatureContext } from &#x27;./FeatureContext&#x27;;\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() =&gt; {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        &lt;FeatureContext.Provider value={currentContext}&gt;\n            {children}\n        &lt;/FeatureContext.Provider&gt;\n    );\n}\n</code></pre></div>\n<p>Usage of this component would look like:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function Forums() {\n  return (\n    &lt;Feature name=&quot;forums&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction Chat() {\n  return (\n    &lt;Feature name=&quot;chat&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction ChatForm() {\n  return (\n    &lt;Feature name=&quot;form&quot;&gt;\n      &lt;SendButton /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\n</code></pre></div>\n<p>Then, in SendButton, when we actually need to use the feature context, we construct the namespace:</p>\n<p><strong>SendButton.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    &lt;button data-track={[...featureContext, &#x27;send&#x27;].join(&#x27;.&#x27;)}&gt;Send&lt;/button&gt;\n  );\n}\n</code></pre></div>\n<p>Note: the above example has been simplified for this article&#x27;s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.</p>\n<p>No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.</p>\n<h2>Conclusion</h2>\n<p>Rather than trying to alleviate string duplication and prop drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop drilling the namespace down to every component.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    mermaid: \"mermaid\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n        children: \"track(namespace)\"\n      }), \").\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Simple Example\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"<button data-track=\\\"chat.form.send\\\">Send<button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And as the tracking grows, these might get moved to a separate file and a constant/enumeration:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"const ChatTracking = {\\n  send: 'chat.form.send',\\n  attachMedia: 'chat.form.attachMedia',\\n  edit: 'chat.messages.edit',\\n  delete: 'chat.messages.delete',\\n} as const;\\n\\n// usage\\n\\n<button data-track={ChatTracking.send}>Send</button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn't end up reducing any of the duplication.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Passing Namespaces\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the application grows more complex, an engineer working on another set of features ends up wanting to reuse the chat form from above. It already has some additional animation and composes the component library widgets, why not reuse it in the context of forums.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Except now the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute has to be passed in as a prop:\"]\n    }), \"\\n\", _jsx(_components.mermaid, {\n      chart: \"graph TD\\n  Forums --> ChatForm\\n  Chat --> ChatForm\\n  ChatForm --> SendButton\\n  SendButton --> Button\\n\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The Forums usage ends up adding its own tracking attribute, but ends up having to prop drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Using Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First let's build a context in React:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"FeatureContext.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { createContext } from 'react';\\n\\n/**\\n * Context for tracking features\\n */\\nexport const FeatureContext = createContext<string[]>([]);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then we'll create a helper component that we can use throughout the application:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Feature.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type { ReactNode } from 'react';\\nimport { useContext, useMemo } from 'react';\\nimport { FeatureContext } from './FeatureContext';\\n\\nexport interface FeatureProps {\\n    readonly name: string;\\n    readonly children: ReactNode;\\n    readonly topLevel?: boolean;\\n}\\n\\nexport function Feature({\\n    name,\\n    children,\\n    topLevel,\\n}: FeatureProps): JSX.Element {\\n    const parentContext = useContext(FeatureContext);\\n\\n    const currentContext = useMemo(() => {\\n        if (topLevel === true) {\\n            return [name];\\n        }\\n        return [...parentContext, name];\\n    }, [parentContext, name, topLevel]);\\n\\n    return (\\n        <FeatureContext.Provider value={currentContext}>\\n            {children}\\n        </FeatureContext.Provider>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Usage of this component would look like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function Forums() {\\n  return (\\n    <Feature name=\\\"forums\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction Chat() {\\n  return (\\n    <Feature name=\\\"chat\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction ChatForm() {\\n  return (\\n    <Feature name=\\\"form\\\">\\n      <SendButton />\\n    </Feature>\\n  );\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then, in SendButton, when we actually need to use the feature context, we construct the namespace:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"SendButton.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function SendButton() {\\n  const featureContext = useContext(FeatureContext);\\n\\n  return (\\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\\n  );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: the above example has been simplified for this article's sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rather than trying to alleviate string duplication and prop drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop drilling the namespace down to every component.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).","excerptHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n      children: \"data-track\"\n    }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n      children: \"track(namespace)\"\n    }), \").\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript","react"]},"previous":{"slug":"2023-08-19-localization","date":"2023-08-19","title":"Enforcing Localization through Types","frontmatter":{"title":"Enforcing Localization through Types","tags":["typescript","react"]},"contentRaw":"\nWhen building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?\n\n## Defining a Localized Type\n\nTypeScript doesn't natively provide an [Opaque type](https://en.wikipedia.org/wiki/Opaque_data_type) that we can use to define a string that has already been localized. If the data looks like a string, TypeScript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in [type-fest](https://github.com/sindresorhus/type-fest):\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA)\n\nHere is a short example where we create a localized string and try to use a raw string and our localized string in a function:\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example('test')); // Will throw a type error\nconsole.log(example(createLocalizedString('test'))); // Works correctly\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA)\n\nNow we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\n\n## Enforcing in Components\n\nThe simplest way we can enforce that strings have already been localized is by using the type in our component's props interface:\n\n```tsx\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n```\n\nNow if we try to use that component without a localized string, we get an error:\n\n```tsx\nimport React from 'react';\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction Example() {\n    return (\n        <>\n            <Button label=\"Test\" />\n            <Button label={createLocalizedString(\"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA)\n\n## Localizing Strings\n\nSo far, we've been using a utility `createLocalizedString` to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we'll want to use a translation function from [react-i18next](https://github.com/i18next/react-i18next) or [next-i18next](https://github.com/i18next/next-i18next) to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\n\n```tsx\nimport React, { useCallback } from 'react';\nimport { Opaque } from 'type-fest';\nimport { useTranslation } from 'react-i18next';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) => {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        <>\n            <Button label={t(\"test\", \"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA)\n\nHere we use `useTranslation` from `react-i18next` and wrap the `t` translation function that is returned to override the type it gives us.\n\nNow when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\n","contentHTML":"<p>When building web applications, enforcing that strings be localized to the user&#x27;s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?</p>\n<h2>Defining a Localized Type</h2>\n<p>TypeScript doesn&#x27;t natively provide an <a href=\"https://en.wikipedia.org/wiki/Opaque_data_type\">Opaque type</a> that we can use to define a string that has already been localized. If the data looks like a string, TypeScript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in <a href=\"https://github.com/sindresorhus/type-fest\">type-fest</a>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\">Playground example</a></p>\n<p>Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example(&#x27;test&#x27;)); // Will throw a type error\nconsole.log(example(createLocalizedString(&#x27;test&#x27;))); // Works correctly\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\">Playground example</a></p>\n<p>Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.</p>\n<h2>Enforcing in Components</h2>\n<p>The simplest way we can enforce that strings have already been localized is by using the type in our component&#x27;s props interface:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n</code></pre></div>\n<p>Now if we try to use that component without a localized string, we get an error:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import React from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction Example() {\n    return (\n        &lt;&gt;\n            &lt;Button label=&quot;Test&quot; /&gt;\n            &lt;Button label={createLocalizedString(&quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\">Playground example</a></p>\n<h2>Localizing Strings</h2>\n<p>So far, we&#x27;ve been using a utility <code>createLocalizedString</code> to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we&#x27;ll want to use a translation function from <a href=\"https://github.com/i18next/react-i18next\">react-i18next</a> or <a href=\"https://github.com/i18next/next-i18next\">next-i18next</a> to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import React, { useCallback } from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\nimport { useTranslation } from &#x27;react-i18next&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) =&gt; {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        &lt;&gt;\n            &lt;Button label={t(&quot;test&quot;, &quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\">Playground example</a></p>\n<p>Here we use <code>useTranslation</code> from <code>react-i18next</code> and wrap the <code>t</code> translation function that is returned to override the type it gives us.</p>\n<p>Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Defining a Localized Type\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"TypeScript doesn't natively provide an \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Opaque_data_type\",\n        children: \"Opaque type\"\n      }), \" that we can use to define a string that has already been localized. If the data looks like a string, TypeScript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in \", _jsx(_components.a, {\n        href: \"https://github.com/sindresorhus/type-fest\",\n        children: \"type-fest\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\nfunction example(s: LocalizedString) {\\n    return s;\\n}\\n\\nconsole.log(example('test')); // Will throw a type error\\nconsole.log(example(createLocalizedString('test'))); // Works correctly\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Enforcing in Components\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The simplest way we can enforce that strings have already been localized is by using the type in our component's props interface:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now if we try to use that component without a localized string, we get an error:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React from 'react';\\nimport { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction Example() {\\n    return (\\n        <>\\n            <Button label=\\\"Test\\\" />\\n            <Button label={createLocalizedString(\\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Localizing Strings\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So far, we've been using a utility \", _jsx(_components.code, {\n        children: \"createLocalizedString\"\n      }), \" to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we'll want to use a translation function from \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/react-i18next\",\n        children: \"react-i18next\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/next-i18next\",\n        children: \"next-i18next\"\n      }), \" to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React, { useCallback } from 'react';\\nimport { Opaque } from 'type-fest';\\nimport { useTranslation } from 'react-i18next';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction useLocalizedTranslation() {\\n    const { t : originalTranslate } = useTranslation();\\n\\n    const t = useCallback((key: string, defaultString: string) => {\\n        return originalTranslate(key, defaultString) as LocalizedString;\\n    }, [originalTranslate]);\\n\\n    return { t };\\n}\\n\\nfunction Example() {\\n    const { t } = useLocalizedTranslation();\\n    return (\\n        <>\\n            <Button label={t(\\\"test\\\", \\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we use \", _jsx(_components.code, {\n        children: \"useTranslation\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"react-i18next\"\n      }), \" and wrap the \", _jsx(_components.code, {\n        children: \"t\"\n      }), \" translation function that is returned to override the type it gives us.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?","excerptHTML":"<p>When building web applications, enforcing that strings be localized to the user&#x27;s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"When building web applications, enforcing that strings be localized to the user's preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in TypeScript?\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript","react"]},"next":{"slug":"2023-08-14-partial-objects","date":"2023-08-14","title":"Forbidden Typescript: full/partial objects","frontmatter":{"title":"Forbidden Typescript: full/partial objects","tags":["typescript"]},"contentRaw":"\nWhen trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\n\n```tsx\n/**\n * An example interface to demonstrate\n */\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial<KnownCodes> = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key in ['code1', 'code2', 'code3']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes as KnownCodes;\n}\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\nIn the above example, we know that `knownCodes` will have all the keys will have values for the interface `KnownCodes`. However, Typescript can’t infer that, so we have to cast the value.\n\nAs the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.\n\nOne way to get around this is to use an assert:\n\n```tsx\ntype RequireAll<T> = {\n  [K in keyof T]-?: T[K];\n};\n\nfunction ensureAllRequired<T>(obj: Partial<T>, template: RequireAll<T>): asserts obj is T {\n  for (const key in template) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial<KnownCodes> = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of ['code1', 'code2']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\n[Playground link](https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA)\n\nThe above code does a **************runtime************** check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.\n\nI have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:\n\n```tsx\n\nfunction ensureAllRequired<T>(obj: Partial<T>): asserts obj is T {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\n```\n\nThe above will let any empty object partial to pass the assert.\n\n## Takeaway\n\nThis ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.\n\nSince we have to create a template object anyway, it is almost always simpler to do the following:\n\n```tsx\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes = { ...TEMPALTE_CODES };\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of ['code1', 'code2', 'code3']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\n[Playground link](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA)\n\nHere we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like `code3`) to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.\n","contentHTML":"<p>When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * An example interface to demonstrate\n */\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial&lt;KnownCodes&gt; = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key in [&#x27;code1&#x27;, &#x27;code2&#x27;, &#x27;code3&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes as KnownCodes;\n}\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p>In the above example, we know that <code>knownCodes</code> will have all the keys will have values for the interface <code>KnownCodes</code>. However, Typescript can’t infer that, so we have to cast the value.</p>\n<p>As the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.</p>\n<p>One way to get around this is to use an assert:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">type RequireAll&lt;T&gt; = {\n  [K in keyof T]-?: T[K];\n};\n\nfunction ensureAllRequired&lt;T&gt;(obj: Partial&lt;T&gt;, template: RequireAll&lt;T&gt;): asserts obj is T {\n  for (const key in template) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial&lt;KnownCodes&gt; = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of [&#x27;code1&#x27;, &#x27;code2&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA\">Playground link</a></p>\n<p>The above code does a <strong><strong><strong><strong><strong><strong><strong>runtime</strong></strong></strong></strong></strong></strong></strong> check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.</p>\n<p>I have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">\nfunction ensureAllRequired&lt;T&gt;(obj: Partial&lt;T&gt;): asserts obj is T {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\n</code></pre></div>\n<p>The above will let any empty object partial to pass the assert.</p>\n<h2>Takeaway</h2>\n<p>This ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.</p>\n<p>Since we have to create a template object anyway, it is almost always simpler to do the following:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">interface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes = { ...TEMPALTE_CODES };\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of [&#x27;code1&#x27;, &#x27;code2&#x27;, &#x27;code3&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA\">Playground link</a></p>\n<p>Here we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like <code>code3</code>) to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * An example interface to demonstrate\\n */\\ninterface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes: Partial<KnownCodes> = {};\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key in ['code1', 'code2', 'code3']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  return knownCodes as KnownCodes;\\n}\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the above example, we know that \", _jsx(_components.code, {\n        children: \"knownCodes\"\n      }), \" will have all the keys will have values for the interface \", _jsx(_components.code, {\n        children: \"KnownCodes\"\n      }), \". However, Typescript can’t infer that, so we have to cast the value.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One way to get around this is to use an assert:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"type RequireAll<T> = {\\n  [K in keyof T]-?: T[K];\\n};\\n\\nfunction ensureAllRequired<T>(obj: Partial<T>, template: RequireAll<T>): asserts obj is T {\\n  for (const key in template) {\\n    if (obj[key] === undefined) {\\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\\n    }\\n  }\\n}\\n\\ninterface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nconst TEMPALTE_CODES: KnownCodes = {\\n  code1: -1,\\n  code2: -1,\\n  code3: -1,\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes: Partial<KnownCodes> = {};\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key of ['code1', 'code2']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\\n\\n  return knownCodes;\\n}\\n\\ncreateValuesForKnownCodes();\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA\",\n        children: \"Playground link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The above code does a \", _jsx(_components.strong, {\n        children: _jsx(_components.strong, {\n          children: _jsx(_components.strong, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.strong, {\n                children: _jsx(_components.strong, {\n                  children: _jsx(_components.strong, {\n                    children: \"runtime\"\n                  })\n                })\n              })\n            })\n          })\n        })\n      }), \" check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"\\nfunction ensureAllRequired<T>(obj: Partial<T>): asserts obj is T {\\n  for (const key in obj) {\\n    if (obj[key] === undefined) {\\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\\n    }\\n  }\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The above will let any empty object partial to pass the assert.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaway\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since we have to create a template object anyway, it is almost always simpler to do the following:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"interface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nconst TEMPALTE_CODES: KnownCodes = {\\n  code1: -1,\\n  code2: -1,\\n  code3: -1,\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes = { ...TEMPALTE_CODES };\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key of ['code1', 'code2', 'code3']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  return knownCodes;\\n}\\n\\ncreateValuesForKnownCodes();\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA\",\n        children: \"Playground link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like \", _jsx(_components.code, {\n        children: \"code3\"\n      }), \") to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:","excerptHTML":"<p>When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript"]}},"__N_SSG":true}