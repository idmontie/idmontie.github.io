{"pageProps":{"headTitle":"react posts - idmontie's Portfolio","headKeywords":"react","tag":"react","posts":[{"slug":"2023-08-19-localization","date":"2023-08-19","title":"Enforcing Localization through Types","frontmatter":{"title":"Enforcing Localization through Types","tags":["typescript","react"]},"contentRaw":"\nWhen building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?\n\n## Defining a Localized Type\n\nTypescript doesn’t natively provide an [Opaque type](https://en.wikipedia.org/wiki/Opaque_data_type) that we can use to define a string that has already been localized. If the data looks like a string, Typescript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in [type-fest](https://github.com/sindresorhus/type-fest):\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA)\n\nHere is a short example where we create a localized string and try to use a raw string and our localized string in a function:\n\n```tsx\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example('test')); // Will throw a type error\nconsole.log(example(createLocalizedString('test'))); // Works correctly\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA)\n\nNow we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\n\n## Enforcing in Components\n\nThe simplest way we can enforce that strings have already been localized is by using the type in our component’s props interface:\n\n```tsx\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n```\n\nNow if we try to use that component without a localized string, we get an error:\n\n```tsx\nimport React from 'react';\nimport { Opaque } from 'type-fest';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction Example() {\n    return (\n        <>\n            <Button label=\"Test\" />\n            <Button label={createLocalizedString(\"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA)\n\n## Localizing Strings\n\nSo far, we’ve been using a utility `createLocalizedString` to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we’ll want to use a translation function from [react-i18next](https://github.com/i18next/react-i18next) or [next-i18next](https://github.com/i18next/next-i18next) to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\n\n```tsx\nimport React, { useCallback } from 'react';\nimport { Opaque } from 'type-fest';\nimport { useTranslation } from 'react-i18next';\n\ntype LocalizedString = Opaque<'LocalizedString', string>;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return <button>{props.label}</button>;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) => {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        <>\n            <Button label={t(\"test\", \"Test\")} />\n        </>\n    );\n}\n```\n\n[Playground example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA)\n\nHere we use `useTranslation` from `react-i18next` and wrap the `t` translation function that is returned to override the type it gives us.\n\nNow when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\n","contentHTML":"<p>When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?</p>\n<h2>Defining a Localized Type</h2>\n<p>Typescript doesn’t natively provide an <a href=\"https://en.wikipedia.org/wiki/Opaque_data_type\">Opaque type</a> that we can use to define a string that has already been localized. If the data looks like a string, Typescript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in <a href=\"https://github.com/sindresorhus/type-fest\">type-fest</a>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\">Playground example</a></p>\n<p>Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\nfunction example(s: LocalizedString) {\n    return s;\n}\n\nconsole.log(example(&#x27;test&#x27;)); // Will throw a type error\nconsole.log(example(createLocalizedString(&#x27;test&#x27;))); // Works correctly\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\">Playground example</a></p>\n<p>Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.</p>\n<h2>Enforcing in Components</h2>\n<p>The simplest way we can enforce that strings have already been localized is by using the type in our component’s props interface:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n</code></pre></div>\n<p>Now if we try to use that component without a localized string, we get an error:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import React from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction Example() {\n    return (\n        &lt;&gt;\n            &lt;Button label=&quot;Test&quot; /&gt;\n            &lt;Button label={createLocalizedString(&quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\">Playground example</a></p>\n<h2>Localizing Strings</h2>\n<p>So far, we’ve been using a utility <code>createLocalizedString</code> to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we’ll want to use a translation function from <a href=\"https://github.com/i18next/react-i18next\">react-i18next</a> or <a href=\"https://github.com/i18next/next-i18next\">next-i18next</a> to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import React, { useCallback } from &#x27;react&#x27;;\nimport { Opaque } from &#x27;type-fest&#x27;;\nimport { useTranslation } from &#x27;react-i18next&#x27;;\n\ntype LocalizedString = Opaque&lt;&#x27;LocalizedString&#x27;, string&gt;;\n\nfunction createLocalizedString(s: string): LocalizedString {\n    return s as LocalizedString;\n}\n\ninterface ButtonProps {\n  label: LocalizedString;\n}\n\nfunction Button(props: ButtonProps) {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n}\n\nfunction useLocalizedTranslation() {\n    const { t : originalTranslate } = useTranslation();\n\n    const t = useCallback((key: string, defaultString: string) =&gt; {\n        return originalTranslate(key, defaultString) as LocalizedString;\n    }, [originalTranslate]);\n\n    return { t };\n}\n\nfunction Example() {\n    const { t } = useLocalizedTranslation();\n    return (\n        &lt;&gt;\n            &lt;Button label={t(&quot;test&quot;, &quot;Test&quot;)} /&gt;\n        &lt;/&gt;\n    );\n}\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\">Playground example</a></p>\n<p>Here we use <code>useTranslation</code> from <code>react-i18next</code> and wrap the <code>t</code> translation function that is returned to override the type it gives us.</p>\n<p>Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Defining a Localized Type\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Typescript doesn’t natively provide an \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Opaque_data_type\",\n        children: \"Opaque type\"\n      }), \" that we can use to define a string that has already been localized. If the data looks like a string, Typescript will consider it a string. We can however use utility types that simulate opaque types, like the Opaque definition in \", _jsx(_components.a, {\n        href: \"https://github.com/sindresorhus/type-fest\",\n        children: \"type-fest\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPnZA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is a short example where we create a localized string and try to use a raw string and our localized string in a function:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\nfunction example(s: LocalizedString) {\\n    return s;\\n}\\n\\nconsole.log(example('test')); // Will throw a type error\\nconsole.log(example(createLocalizedString('test'))); // Works correctly\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgeTAQwI4FcCmcC+cAZlBCHAOQwCeYOAtETgM4wUDcAUJzXXADIQAxmgA2wAF44AJgGUYUYADsA5nAC8KdNhwAeCoJHipchcpUUANHFaLVAPi6ciWJUJjAISuEKg40MDiGYpIy8nYqABTMAFw2ZqoAlHHBxmEJagiccDlwfjBYUN7McGglqaGmEVz43C5uHl5wOAAeaOCiONEpwiEm4eaJiNm5+YXFNdxCXswQnQB0ohBRre1gnZFULGyJiVzTSrMLSyttHV2+-oEV-RmbgawUu3tAA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we have a type that we can use in our function and components to denote that we expect an already localized string to be used.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Enforcing in Components\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The simplest way we can enforce that strings have already been localized is by using the type in our component’s props interface:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now if we try to use that component without a localized string, we get an error:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React from 'react';\\nimport { Opaque } from 'type-fest';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction Example() {\\n    return (\\n        <>\\n            <Button label=\\\"Test\\\" />\\n            <Button label={createLocalizedString(\\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wG4AoUSWOAbzgHkwUBHAVyTgF85tcCYATzBIAtJiQBnGGXLkhIuABkIaFABtgALyQATAMowowAHYBzOAF5GzdkgA8+FWs06DR02fwAaONOPmAHwU5JhsJhjAECZwaEQoMEjOGtp6hgFmABSSAFx+HuYAlHnJrmkFFrTkcDVwRDBsUDGScCgtpanuGRRccqaJUJjonABCbDAw0QAKOGAtVTXqKABGSOolqilu6Z49cmERMFExYxPRmWCzuXCnkyYzEHOFdNV1SA1NcPbL43eBtJdHpIAHRLVbqLj2AD0PzOJmC5F6oXCkWicAAogAPFDgdRITLPBa1eqNGKZV61Wr2QIUyl0+y3NFgtaWABEABUpDBWXAoTS6QKvoyYsz1JZaHFUIkOtsKpkOVzWYUeHzaZTofzaoUekA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Localizing Strings\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So far, we’ve been using a utility \", _jsx(_components.code, {\n        children: \"createLocalizedString\"\n      }), \" to create and use the LocalizedString type. This utility is only really practical in unit tests. For real applications, we’ll want to use a translation function from \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/react-i18next\",\n        children: \"react-i18next\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"https://github.com/i18next/next-i18next\",\n        children: \"next-i18next\"\n      }), \" to do the heavy lifting. Then we just wrap the translation functions that are provided in order to use our type:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React, { useCallback } from 'react';\\nimport { Opaque } from 'type-fest';\\nimport { useTranslation } from 'react-i18next';\\n\\ntype LocalizedString = Opaque<'LocalizedString', string>;\\n\\nfunction createLocalizedString(s: string): LocalizedString {\\n    return s as LocalizedString;\\n}\\n\\ninterface ButtonProps {\\n  label: LocalizedString;\\n}\\n\\nfunction Button(props: ButtonProps) {\\n  return <button>{props.label}</button>;\\n}\\n\\nfunction useLocalizedTranslation() {\\n    const { t : originalTranslate } = useTranslation();\\n\\n    const t = useCallback((key: string, defaultString: string) => {\\n        return originalTranslate(key, defaultString) as LocalizedString;\\n    }, [originalTranslate]);\\n\\n    return { t };\\n}\\n\\nfunction Example() {\\n    const { t } = useLocalizedTranslation();\\n    return (\\n        <>\\n            <Button label={t(\\\"test\\\", \\\"Test\\\")} />\\n        </>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMIoA25ARugNZwC+cAZlBCHAORSoacDcAKFCRYuOAHkwKAI74kjFmw6cYATzBIAtMySEYA4eGjw8RJABUoKAHaFyKGMAg3Frdlx7oYW4AEYADhskAA8DIUF1TTgAGQg0CmAALyQAEwBlGChgGwBzOABeSWk5JAAeTjiE8mS0zOy8zmx9BtyAPgjmfBsMZ1c0LxgkKsSUjKyc3IAKQgAuOBbJgEp5kZqx+sncQThduB4YfChXQjgUU7Xa8dahBkFhGyGoZnQFACF8GBgXAAU2MFOOB2cAcVCQ5FW8VGdQmeVu9y6PScLjgHy+LimYH+c1Rn2+Nj+EABS22uwOR1cZSoeJcbRwWKJhAAdKDwQwygB6anomwdQR3QSI3oo8yXMZWWz2Rx9KYkoF7OBoFz6cTwebQYC5HIUCV2BxDRRFcy6qXImyyiIKpV2eDwI3EMiUGhoWhTKa0JBqeaLPLYVJIF74cgwTZ5b2w3IkgptUkKvbk45wDVamw66x6xxId2ev0BlBBkMRknnWJQ9Ywm7A3YMbAAbWT2vIJv1SAAuktLfGkIdE3h4Ax4YLusLXABREIocDkLNyquK5WmOD9woEYhitLN6UYjtzhOuKZzhVlNqHuO7Mpo-EglBg8gFHAwKYAIiG+if2CfFj0MCfSyYHJPM9zwAucdwYIA\",\n        children: \"Playground example\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we use \", _jsx(_components.code, {\n        children: \"useTranslation\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"react-i18next\"\n      }), \" and wrap the \", _jsx(_components.code, {\n        children: \"t\"\n      }), \" translation function that is returned to override the type it gives us.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now when engineers go to use the Button component, they will know they need a LocalizedString, and the most straightforward way to get it will be to use the i18next utilities that we also provide.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?","excerptHTML":"<p>When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"When building web applications, enforcing that strings be localized to the user’s preferred language can sometimes be achieved via lint rules. But what if we could enforce proper localization using types in Typescript?\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript","react"]},{"slug":"2023-08-17-feature-context","date":"2023-08-17","title":"Feature Contexts","frontmatter":{"title":"Feature Contexts","tags":["typescript","react"]},"contentRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).\n\n## Simple Example\n\nAs requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\n\n```tsx\n<button data-track=\"chat.form.send\">Send<button>\n```\n\nAnd as the tracking grows, these might get moved to a separate file and a constant/enumeration:\n\n```tsx\nconst ChatTracking = {\n  send: 'chat.form.send',\n  attachMedia: 'chat.form.attachMedia',\n  edit: 'chat.messages.edit',\n  delete: 'chat.messages.delete',\n} as const;\n\n// usage\n\n<button data-track={ChatTracking.send}>Send</button>\n```\n\nWe have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn’t end up reducing any of the duplication.\n\n## Passing Namespaces\n\nAs the application grows more complex, an engineer working on another set of features ends up wanting to re-use the chat form from above. It already has some additional animation and composes together the component library widgets, why not re-use it in the context of forums.\n\nExcept now the `data-track` attribute has to be passed in as a prop:\n\n```mermaid\ngraph TD\n  Forums --> ChatForm\n  Chat --> ChatForm\n  ChatForm --> SendButton\n  SendButton --> Button\n\n```\n\nThe Forums usage ends up adding its own tracking attribute, but ends up having to prop-drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\n\n## Using Context\n\nInstead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\n\nFirst let’s build a context in React:\n\n**FeatureContext.tsx**\n\n```tsx\nimport { createContext } from 'react';\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext<string[]>([]);\n```\n\nThen we’ll create a helper component that we can use throughout the application:\n\n**Feature.tsx**\n\n```tsx\nimport type { ReactNode } from 'react';\nimport { useContext, useMemo } from 'react';\nimport { FeatureContext } from './FeatureContext';\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() => {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        <FeatureContext.Provider value={currentContext}>\n            {children}\n        </FeatureContext.Provider>\n    );\n}\n```\n\nUsage of this component would look like:\n\n```tsx\nfunction Forums() {\n  return (\n    <Feature name=\"forums\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction Chat() {\n  return (\n    <Feature name=\"chat\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction ChatForm() {\n  return (\n    <Feature name=\"form\">\n      <SendButton />\n    </Feature>\n  );\n}\n\n```\n\nThen, in SendButton, when we actually need to use the feature context, we construct the namespace:\n\n**SendButton.tsx**\n\n```tsx\nfunction SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\n  );\n}\n```\n\nNote: the above example has been simplified for this article’s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\n\nNo additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\n\n## Conclusion\n\nRather than trying to alleviate string duplication and prop-drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop-drilling the namespace down to every component.\n","contentHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>\n<h2>Simple Example</h2>\n<p>As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">&lt;button data-track=&quot;chat.form.send&quot;&gt;Send&lt;button&gt;\n</code></pre></div>\n<p>And as the tracking grows, these might get moved to a separate file and a constant/enumeration:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">const ChatTracking = {\n  send: &#x27;chat.form.send&#x27;,\n  attachMedia: &#x27;chat.form.attachMedia&#x27;,\n  edit: &#x27;chat.messages.edit&#x27;,\n  delete: &#x27;chat.messages.delete&#x27;,\n} as const;\n\n// usage\n\n&lt;button data-track={ChatTracking.send}&gt;Send&lt;/button&gt;\n</code></pre></div>\n<p>We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn’t end up reducing any of the duplication.</p>\n<h2>Passing Namespaces</h2>\n<p>As the application grows more complex, an engineer working on another set of features ends up wanting to re-use the chat form from above. It already has some additional animation and composes together the component library widgets, why not re-use it in the context of forums.</p>\n<p>Except now the <code>data-track</code> attribute has to be passed in as a prop:</p>\n<mermaid chart=\"graph TD\n  Forums --&gt; ChatForm\n  Chat --&gt; ChatForm\n  ChatForm --&gt; SendButton\n  SendButton --&gt; Button\n\"></mermaid>\n<p>The Forums usage ends up adding its own tracking attribute, but ends up having to prop-drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.</p>\n<h2>Using Context</h2>\n<p>Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.</p>\n<p>First let’s build a context in React:</p>\n<p><strong>FeatureContext.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { createContext } from &#x27;react&#x27;;\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext&lt;string[]&gt;([]);\n</code></pre></div>\n<p>Then we’ll create a helper component that we can use throughout the application:</p>\n<p><strong>Feature.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import type { ReactNode } from &#x27;react&#x27;;\nimport { useContext, useMemo } from &#x27;react&#x27;;\nimport { FeatureContext } from &#x27;./FeatureContext&#x27;;\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() =&gt; {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        &lt;FeatureContext.Provider value={currentContext}&gt;\n            {children}\n        &lt;/FeatureContext.Provider&gt;\n    );\n}\n</code></pre></div>\n<p>Usage of this component would look like:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function Forums() {\n  return (\n    &lt;Feature name=&quot;forums&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction Chat() {\n  return (\n    &lt;Feature name=&quot;chat&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction ChatForm() {\n  return (\n    &lt;Feature name=&quot;form&quot;&gt;\n      &lt;SendButton /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\n</code></pre></div>\n<p>Then, in SendButton, when we actually need to use the feature context, we construct the namespace:</p>\n<p><strong>SendButton.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    &lt;button data-track={[...featureContext, &#x27;send&#x27;].join(&#x27;.&#x27;)}&gt;Send&lt;/button&gt;\n  );\n}\n</code></pre></div>\n<p>Note: the above example has been simplified for this article’s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.</p>\n<p>No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.</p>\n<h2>Conclusion</h2>\n<p>Rather than trying to alleviate string duplication and prop-drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop-drilling the namespace down to every component.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    mermaid: \"mermaid\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n        children: \"track(namespace)\"\n      }), \").\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Simple Example\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"<button data-track=\\\"chat.form.send\\\">Send<button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And as the tracking grows, these might get moved to a separate file and a constant/enumeration:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"const ChatTracking = {\\n  send: 'chat.form.send',\\n  attachMedia: 'chat.form.attachMedia',\\n  edit: 'chat.messages.edit',\\n  delete: 'chat.messages.delete',\\n} as const;\\n\\n// usage\\n\\n<button data-track={ChatTracking.send}>Send</button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn’t end up reducing any of the duplication.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Passing Namespaces\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the application grows more complex, an engineer working on another set of features ends up wanting to re-use the chat form from above. It already has some additional animation and composes together the component library widgets, why not re-use it in the context of forums.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Except now the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute has to be passed in as a prop:\"]\n    }), \"\\n\", _jsx(_components.mermaid, {\n      chart: \"graph TD\\n  Forums --> ChatForm\\n  Chat --> ChatForm\\n  ChatForm --> SendButton\\n  SendButton --> Button\\n\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The Forums usage ends up adding its own tracking attribute, but ends up having to prop-drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Using Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First let’s build a context in React:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"FeatureContext.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { createContext } from 'react';\\n\\n/**\\n * Context for tracking features\\n */\\nexport const FeatureContext = createContext<string[]>([]);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then we’ll create a helper component that we can use throughout the application:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Feature.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type { ReactNode } from 'react';\\nimport { useContext, useMemo } from 'react';\\nimport { FeatureContext } from './FeatureContext';\\n\\nexport interface FeatureProps {\\n    readonly name: string;\\n    readonly children: ReactNode;\\n    readonly topLevel?: boolean;\\n}\\n\\nexport function Feature({\\n    name,\\n    children,\\n    topLevel,\\n}: FeatureProps): JSX.Element {\\n    const parentContext = useContext(FeatureContext);\\n\\n    const currentContext = useMemo(() => {\\n        if (topLevel === true) {\\n            return [name];\\n        }\\n        return [...parentContext, name];\\n    }, [parentContext, name, topLevel]);\\n\\n    return (\\n        <FeatureContext.Provider value={currentContext}>\\n            {children}\\n        </FeatureContext.Provider>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Usage of this component would look like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function Forums() {\\n  return (\\n    <Feature name=\\\"forums\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction Chat() {\\n  return (\\n    <Feature name=\\\"chat\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction ChatForm() {\\n  return (\\n    <Feature name=\\\"form\\\">\\n      <SendButton />\\n    </Feature>\\n  );\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then, in SendButton, when we actually need to use the feature context, we construct the namespace:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"SendButton.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function SendButton() {\\n  const featureContext = useContext(FeatureContext);\\n\\n  return (\\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\\n  );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: the above example has been simplified for this article’s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rather than trying to alleviate string duplication and prop-drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop-drilling the namespace down to every component.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).","excerptHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n      children: \"data-track\"\n    }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n      children: \"track(namespace)\"\n    }), \").\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript","react"]}]},"__N_SSG":true}