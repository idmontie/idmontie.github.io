{"pageProps":{"posts":[{"slug":"2023-08-17-feature-context","date":"2023-08-17","title":"Feature Context","frontmatter":{"title":"Feature Context"},"contentRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).\n\n## Simple Example\n\nAs requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\n\n```tsx\n<button data-track=\"chat.form.send\">Send<button>\n```\n\nAnd as the tracking grows, these might get moved to a separate file and a constant/enumeration:\n\n```tsx\nconst ChatTracking = {\n  send: 'chat.form.send',\n  attachMedia: 'chat.form.attachMedia',\n  edit: 'chat.messages.edit',\n  delete: 'chat.messages.delete',\n} as const;\n\n// usage\n\n<button data-track={ChatTracking.send}>Send</button>\n```\n\nWe have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn’t end up reducing any of the duplication.\n\n## Passing Namespaces\n\nAs the application grows more complex, an engineer working on another set of features ends up wanting to re-use the chat form from above. It already has some additional animation and composes together the component library widgets, why not re-use it in the context of forums.\n\nExcept now the `data-track` attribute has to be passed in as a prop:\n\n```mermaid\ngraph TD\n  Forums --> ChatForm\n  Chat --> ChatForm\n  ChatForm --> SendButton\n  SendButton --> Button\n\n```\n\nThe Forums usage ends up adding its own tracking attribute, but ends up having to prop-drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\n\n## Using Context\n\nInstead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\n\nFirst let’s build a context in React:\n\n**FeatureContext.tsx**\n\n```tsx\nimport { createContext } from 'react';\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext<string[]>([]);\n```\n\nThen we’ll create a helper component that we can use throughout the application:\n\n**Feature.tsx**\n\n```tsx\nimport type { ReactNode } from 'react';\nimport { useContext, useMemo } from 'react';\nimport { FeatureContext } from './FeatureContext';\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() => {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        <FeatureContext.Provider value={currentContext}>\n            {children}\n        </FeatureContext.Provider>\n    );\n}\n```\n\nUsage of this component would look like:\n\n```tsx\nfunction Forums() {\n  return (\n    <Feature name=\"forums\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction Chat() {\n  return (\n    <Feature name=\"chat\">\n      <ChatForm />\n    </Feature>\n  );\n}\n\nfunction ChatForm() {\n  return (\n    <Feature name=\"form\">\n      <SendButton />\n    </Feature>\n  );\n}\n\n```\n\nThen, in SendButton, when we actually need to use the feature context, we construct the namespace:\n\n**SendButton.tsx**\n\n```tsx\nfunction SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\n  );\n}\n```\n\nNote: the above example has been simplified for this article’s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\n\nNo additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\n\n## Conclusion\n\nRather than trying to alleviate string duplication and prop-drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop-drilling the namespace down to every component.\n","contentHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>\n<h2>Simple Example</h2>\n<p>As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">&lt;button data-track=&quot;chat.form.send&quot;&gt;Send&lt;button&gt;\n</code></pre></div>\n<p>And as the tracking grows, these might get moved to a separate file and a constant/enumeration:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">const ChatTracking = {\n  send: &#x27;chat.form.send&#x27;,\n  attachMedia: &#x27;chat.form.attachMedia&#x27;,\n  edit: &#x27;chat.messages.edit&#x27;,\n  delete: &#x27;chat.messages.delete&#x27;,\n} as const;\n\n// usage\n\n&lt;button data-track={ChatTracking.send}&gt;Send&lt;/button&gt;\n</code></pre></div>\n<p>We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn’t end up reducing any of the duplication.</p>\n<h2>Passing Namespaces</h2>\n<p>As the application grows more complex, an engineer working on another set of features ends up wanting to re-use the chat form from above. It already has some additional animation and composes together the component library widgets, why not re-use it in the context of forums.</p>\n<p>Except now the <code>data-track</code> attribute has to be passed in as a prop:</p>\n<div class=\"py-8 [&amp;_svg]:m-auto\"><div class=\"mermaid\" data-mermaid-src=\"graph TD\n  Forums --&gt; ChatForm\n  Chat --&gt; ChatForm\n  ChatForm --&gt; SendButton\n  SendButton --&gt; Button\n\">graph TD\n  Forums --&gt; ChatForm\n  Chat --&gt; ChatForm\n  ChatForm --&gt; SendButton\n  SendButton --&gt; Button\n</div></div>\n<p>The Forums usage ends up adding its own tracking attribute, but ends up having to prop-drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.</p>\n<h2>Using Context</h2>\n<p>Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.</p>\n<p>First let’s build a context in React:</p>\n<p><strong>FeatureContext.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import { createContext } from &#x27;react&#x27;;\n\n/**\n * Context for tracking features\n */\nexport const FeatureContext = createContext&lt;string[]&gt;([]);\n</code></pre></div>\n<p>Then we’ll create a helper component that we can use throughout the application:</p>\n<p><strong>Feature.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">import type { ReactNode } from &#x27;react&#x27;;\nimport { useContext, useMemo } from &#x27;react&#x27;;\nimport { FeatureContext } from &#x27;./FeatureContext&#x27;;\n\nexport interface FeatureProps {\n    readonly name: string;\n    readonly children: ReactNode;\n    readonly topLevel?: boolean;\n}\n\nexport function Feature({\n    name,\n    children,\n    topLevel,\n}: FeatureProps): JSX.Element {\n    const parentContext = useContext(FeatureContext);\n\n    const currentContext = useMemo(() =&gt; {\n        if (topLevel === true) {\n            return [name];\n        }\n        return [...parentContext, name];\n    }, [parentContext, name, topLevel]);\n\n    return (\n        &lt;FeatureContext.Provider value={currentContext}&gt;\n            {children}\n        &lt;/FeatureContext.Provider&gt;\n    );\n}\n</code></pre></div>\n<p>Usage of this component would look like:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function Forums() {\n  return (\n    &lt;Feature name=&quot;forums&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction Chat() {\n  return (\n    &lt;Feature name=&quot;chat&quot;&gt;\n      &lt;ChatForm /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\nfunction ChatForm() {\n  return (\n    &lt;Feature name=&quot;form&quot;&gt;\n      &lt;SendButton /&gt;\n    &lt;/Feature&gt;\n  );\n}\n\n</code></pre></div>\n<p>Then, in SendButton, when we actually need to use the feature context, we construct the namespace:</p>\n<p><strong>SendButton.tsx</strong></p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">function SendButton() {\n  const featureContext = useContext(FeatureContext);\n\n  return (\n    &lt;button data-track={[...featureContext, &#x27;send&#x27;].join(&#x27;.&#x27;)}&gt;Send&lt;/button&gt;\n  );\n}\n</code></pre></div>\n<p>Note: the above example has been simplified for this article’s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.</p>\n<p>No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.</p>\n<h2>Conclusion</h2>\n<p>Rather than trying to alleviate string duplication and prop-drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop-drilling the namespace down to every component.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    pre: \"pre\",\n    strong: \"strong\"\n  }, props.components), {Mermaid} = _components;\n  if (!Mermaid) _missingMdxReference(\"Mermaid\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n        children: \"track(namespace)\"\n      }), \").\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Simple Example\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As requests to start tracking user events come up, typically the easiest way is to just hard code the tracking namespaces:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"<button data-track=\\\"chat.form.send\\\">Send<button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And as the tracking grows, these might get moved to a separate file and a constant/enumeration:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"const ChatTracking = {\\n  send: 'chat.form.send',\\n  attachMedia: 'chat.form.attachMedia',\\n  edit: 'chat.messages.edit',\\n  delete: 'chat.messages.delete',\\n} as const;\\n\\n// usage\\n\\n<button data-track={ChatTracking.send}>Send</button>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We have a lot of string duplication here. We might be tempted to use template strings or some other way of creating the string, but it doesn’t end up reducing any of the duplication.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Passing Namespaces\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the application grows more complex, an engineer working on another set of features ends up wanting to re-use the chat form from above. It already has some additional animation and composes together the component library widgets, why not re-use it in the context of forums.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Except now the \", _jsx(_components.code, {\n        children: \"data-track\"\n      }), \" attribute has to be passed in as a prop:\"]\n    }), \"\\n\", _jsx(Mermaid, {\n      chart: \"graph TD\\n  Forums --> ChatForm\\n  Chat --> ChatForm\\n  ChatForm --> SendButton\\n  SendButton --> Button\\n\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The Forums usage ends up adding its own tracking attribute, but ends up having to prop-drill down the namespace from the Forums components, through the ChatForm, to the SendButton component.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Using Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Instead, what if we wrap our features in some Context component that helps us track where our components are being used. Then we can just build up the tracking namespace based on where the component is in the feature tree, rather than having to keep track of long namespace strings.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First let’s build a context in React:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"FeatureContext.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { createContext } from 'react';\\n\\n/**\\n * Context for tracking features\\n */\\nexport const FeatureContext = createContext<string[]>([]);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then we’ll create a helper component that we can use throughout the application:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Feature.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type { ReactNode } from 'react';\\nimport { useContext, useMemo } from 'react';\\nimport { FeatureContext } from './FeatureContext';\\n\\nexport interface FeatureProps {\\n    readonly name: string;\\n    readonly children: ReactNode;\\n    readonly topLevel?: boolean;\\n}\\n\\nexport function Feature({\\n    name,\\n    children,\\n    topLevel,\\n}: FeatureProps): JSX.Element {\\n    const parentContext = useContext(FeatureContext);\\n\\n    const currentContext = useMemo(() => {\\n        if (topLevel === true) {\\n            return [name];\\n        }\\n        return [...parentContext, name];\\n    }, [parentContext, name, topLevel]);\\n\\n    return (\\n        <FeatureContext.Provider value={currentContext}>\\n            {children}\\n        </FeatureContext.Provider>\\n    );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Usage of this component would look like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function Forums() {\\n  return (\\n    <Feature name=\\\"forums\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction Chat() {\\n  return (\\n    <Feature name=\\\"chat\\\">\\n      <ChatForm />\\n    </Feature>\\n  );\\n}\\n\\nfunction ChatForm() {\\n  return (\\n    <Feature name=\\\"form\\\">\\n      <SendButton />\\n    </Feature>\\n  );\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then, in SendButton, when we actually need to use the feature context, we construct the namespace:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"SendButton.tsx\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function SendButton() {\\n  const featureContext = useContext(FeatureContext);\\n\\n  return (\\n    <button data-track={[...featureContext, 'send'].join('.')}>Send</button>\\n  );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: the above example has been simplified for this article’s sake. Typically some utility for reading the context, joining the namespaces, and memoizing the value would be provided.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No additional props are needed, and the Feature components can be used throughout the application as a standard mechanism for building up feature namespaces.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rather than trying to alleviate string duplication and prop-drilling as separate problems, we can leverage React Context to solve both problems at the same time and leverage context to determine where we are in a feature tree. Not only does the Feature context help with constructing the data-track attributes, but it now provides a consistent mechanism that we can use throughout the application to let components know the feature namespace they are currently in without the parent components prop-drilling the namespace down to every component.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","excerptRaw":"\nA common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the `data-track` attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. `track(namespace)`).","excerptHTML":"<p>A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the <code>data-track</code> attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. <code>track(namespace)</code>).</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\"\n  }, props.components);\n  return _jsxs(_components.p, {\n    children: [\"A common pattern in larger application when trying to track feature usage is to try to namespace events. For example, you might have a button that you want to track clicks on. For the sake of this article, we will use the \", _jsx(_components.code, {\n      children: \"data-track\"\n    }), \" attribute on elements to track their usage, but you can imagine this works with any tracking implementation where you may need to explicitly call a tracking function (e.g. \", _jsx(_components.code, {\n      children: \"track(namespace)\"\n    }), \").\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]},{"slug":"2023-08-14-partial-objects","date":"2023-08-14","title":"Forbidden Typescript: full/partial objects","frontmatter":{"title":"Forbidden Typescript: full/partial objects","tags":["typescript"]},"contentRaw":"\nWhen trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\n\n```tsx\n/**\n * An example interface to demonstrate\n */\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial<KnownCodes> = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key in ['code1', 'code2', 'code3']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes as KnownCodes;\n}\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\nIn the above example, we know that `knownCodes` will have all the keys will have values for the interface `KnownCodes`. However, Typescript can’t infer that, so we have to cast the value.\n\nAs the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.\n\nOne way to get around this is to use an assert:\n\n```tsx\ntype RequireAll<T> = {\n  [K in keyof T]-?: T[K];\n};\n\nfunction ensureAllRequired<T>(obj: Partial<T>, template: RequireAll<T>): asserts obj is T {\n  for (const key in template) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial<KnownCodes> = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of ['code1', 'code2']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\n[Playground link](https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA)\n\nThe above code does a **************runtime************** check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.\n\nI have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:\n\n```tsx\n\nfunction ensureAllRequired<T>(obj: Partial<T>): asserts obj is T {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\n```\n\nThe above will let any empty object partial to pass the assert.\n\n## Takeaway\n\nThis ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.\n\nSince we have to create a template object anyway, it is almost always simpler to do the following:\n\n```tsx\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes = { ...TEMPALTE_CODES };\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of ['code1', 'code2', 'code3']) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n```\n\n[Playground link](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA)\n\nHere we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like `code3`) to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.\n","contentHTML":"<p>When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">/**\n * An example interface to demonstrate\n */\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial&lt;KnownCodes&gt; = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key in [&#x27;code1&#x27;, &#x27;code2&#x27;, &#x27;code3&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes as KnownCodes;\n}\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p>In the above example, we know that <code>knownCodes</code> will have all the keys will have values for the interface <code>KnownCodes</code>. However, Typescript can’t infer that, so we have to cast the value.</p>\n<p>As the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.</p>\n<p>One way to get around this is to use an assert:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">type RequireAll&lt;T&gt; = {\n  [K in keyof T]-?: T[K];\n};\n\nfunction ensureAllRequired&lt;T&gt;(obj: Partial&lt;T&gt;, template: RequireAll&lt;T&gt;): asserts obj is T {\n  for (const key in template) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\ninterface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes: Partial&lt;KnownCodes&gt; = {};\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of [&#x27;code1&#x27;, &#x27;code2&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA\">Playground link</a></p>\n<p>The above code does a <strong><strong><strong><strong><strong><strong><strong>runtime</strong></strong></strong></strong></strong></strong></strong> check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.</p>\n<p>I have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">\nfunction ensureAllRequired&lt;T&gt;(obj: Partial&lt;T&gt;): asserts obj is T {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\n    }\n  }\n}\n\n</code></pre></div>\n<p>The above will let any empty object partial to pass the assert.</p>\n<h2>Takeaway</h2>\n<p>This ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.</p>\n<p>Since we have to create a template object anyway, it is almost always simpler to do the following:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">interface KnownCodes {\n  code1: number;\n  code2: number;\n  code3: number;\n}\n\nconst TEMPALTE_CODES: KnownCodes = {\n  code1: -1,\n  code2: -1,\n  code3: -1,\n}\n\nfunction createValuesForKnownCodes(): KnownCodes {\n  const knownCodes = { ...TEMPALTE_CODES };\n\n  // In a real example, these keys may come from some other object\n  // or external data\n  for (const key of [&#x27;code1&#x27;, &#x27;code2&#x27;, &#x27;code3&#x27;]) {\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\n  }\n\n  return knownCodes;\n}\n\ncreateValuesForKnownCodes();\n\n// Stub for the example\nfunction dynamicValue(key: string) { return 0 };\n</code></pre></div>\n<p><a href=\"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA\">Playground link</a></p>\n<p>Here we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like <code>code3</code>) to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    strong: \"strong\",\n    h2: \"h2\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"/**\\n * An example interface to demonstrate\\n */\\ninterface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes: Partial<KnownCodes> = {};\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key in ['code1', 'code2', 'code3']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  return knownCodes as KnownCodes;\\n}\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the above example, we know that \", _jsx(_components.code, {\n        children: \"knownCodes\"\n      }), \" will have all the keys will have values for the interface \", _jsx(_components.code, {\n        children: \"KnownCodes\"\n      }), \". However, Typescript can’t infer that, so we have to cast the value.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the function gets more complex with additional feature work, this can become brittle and lead to some type-holes where we may have accidentally forgotten to set a key.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One way to get around this is to use an assert:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"type RequireAll<T> = {\\n  [K in keyof T]-?: T[K];\\n};\\n\\nfunction ensureAllRequired<T>(obj: Partial<T>, template: RequireAll<T>): asserts obj is T {\\n  for (const key in template) {\\n    if (obj[key] === undefined) {\\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\\n    }\\n  }\\n}\\n\\ninterface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nconst TEMPALTE_CODES: KnownCodes = {\\n  code1: -1,\\n  code2: -1,\\n  code3: -1,\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes: Partial<KnownCodes> = {};\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key of ['code1', 'code2']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  ensureAllRequired(knownCodes, TEMPALTE_CODES);\\n\\n  return knownCodes;\\n}\\n\\ncreateValuesForKnownCodes();\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShCOBXAlgJwgQQDZYDwBUA+KAXigG8AoKKAbQGkpkA7KAawhAHsAzKfALoBaAPwAufgwEBuSgF9ZlHomYBjYMi6sIzAM6J02LHCRoIAEwKEAFFwBGAKwkAFAIaoNrvEQA0UYBAAtmBYrgESJiiGOFYAlBKuuroQHrpQ9g5MafgU1FA8XKhQ1qpausDsnEysAcGhAbG5NDTIfLaOtBwgAqQkZCrmEDwsFo1Uzc3AABaoXADuUMwQCwCiqLOo1gAGALLISSwA5lDopujmUGCzkB4gEgAk5F1y1VCPAFIAygDyAHIAdOVUEdWiB2g5YnItrFZBM5Hl4fDKCwAqgeK5VNB6Mx5swAMJcQZpcZQUqDACMEmYiECdhSsNJhIgACYqTS6ahZABIMkQADMbNp9PklEopT0FXwKx2zgwABkpQB9PHfAAiK0+EmxuIJRNITUZFIkQnJPjyvNZUBNZpovIFVtNIqUKnUmlYqnQYQgADUvIgILoAGKFbVzfFM3TWeJQUPhvUk8Xldg4sO6gMudyePCxtO6YhkcgKUU0AD0JagAElWK4ThAvFAIAAPVx1CB+aYB6BdNKBVwgRmBaA8WaBKC6LiD9IdooZCDqPJl9JFJuo5j18xhVx5ApFEplCpddJ8WgAcl55JPfjPTOZJ4EYzyzTYKbjAc6VUSlW4fBzEZ6ZHMEA10CZBVF9LB-WsLoYQRYsGz0AxMBwSIzHMKCX1zPwpRleUlRVdVPhgvJ0GAAxWGfHUI1kJEPTrAJwP9IMQwwiMo0URdPlIux8kKfwpmgJsWxCCBnTUDQtCgQDgNAhiICgzgJCBI4xlrUjUFYAAGKAiyAA\",\n        children: \"Playground link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The above code does a \", _jsx(_components.strong, {\n        children: _jsx(_components.strong, {\n          children: _jsx(_components.strong, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.strong, {\n                children: _jsx(_components.strong, {\n                  children: _jsx(_components.strong, {\n                    children: \"runtime\"\n                  })\n                })\n              })\n            })\n          })\n        })\n      }), \" check that the object has all the keys that are defined in the template. This ensure that any missing keys are caught as well.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I have seen other examples online where only the object is passed in, but this ends up not working if the keys are not defined in the object:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"\\nfunction ensureAllRequired<T>(obj: Partial<T>): asserts obj is T {\\n  for (const key in obj) {\\n    if (obj[key] === undefined) {\\n      throw new Error(`Missing required property: ${key} in ${JSON.stringify(obj)}`);\\n    }\\n  }\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The above will let any empty object partial to pass the assert.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Takeaway\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This ends up being a lot of work to do a runtime check to improve our typings, which I’m not sure is the best approach. Most of the time when we construct objects from an empty object, it’s difficult to ensure that the full object has been safely created.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since we have to create a template object anyway, it is almost always simpler to do the following:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"interface KnownCodes {\\n  code1: number;\\n  code2: number;\\n  code3: number;\\n}\\n\\nconst TEMPALTE_CODES: KnownCodes = {\\n  code1: -1,\\n  code2: -1,\\n  code3: -1,\\n}\\n\\nfunction createValuesForKnownCodes(): KnownCodes {\\n  const knownCodes = { ...TEMPALTE_CODES };\\n\\n  // In a real example, these keys may come from some other object\\n  // or external data\\n  for (const key of ['code1', 'code2', 'code3']) {\\n     knownCodes[key as keyof KnownCodes] = dynamicValue(key);\\n  }\\n\\n  return knownCodes;\\n}\\n\\ncreateValuesForKnownCodes();\\n\\n// Stub for the example\\nfunction dynamicValue(key: string) { return 0 };\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgNIgPYHcQGEMAmEAzsgN4BQyyChEAjAFzIgCuAtgEbQDcVNdAEzM2XXv1pEAzCI7cofAL4UKtEMTDIAKgFEAsgAUAggBldAfVwB5ACI6Ays3TY8dUgF5yEuk2QBaegAabyJhfyCQiBlw4OUKGFYQBDBgDBAaKAg4SAA1OAAbVhIAMQwoZxx8ImIACgBKJ0xKty9qNQ1kAGsm12rkTzJkADoR3UNTC2s7e2RFPn4AegXkAEl0uGRMguQIAA84dgAHfIhA5DAACxIUTogAT1J2ODuBdhQYKAx2ZGIvlAxLtBkBhOAArCDJRbLMo7XaQKAgbYEbJwfgwGE1dqaW4vDAwZAAbQA5JIGESziShOTkJTpESALp1VrUajdFxVEgEnHIOCkHF4tA9DnEen9ZAEO6I9jABB5QoQGo4up8ahxaiZMCsBFdIVuJQqBBbXIFIrEUrlXXVerzJbIeyazjIdFQc5XWEHY4QeKJZKpdISqUyuVFRX3ZgaKCgADmTMGGq16QADLM+EA\",\n        children: \"Playground link\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we take the easy way out and clone the template and then built the object from there. Even if we forget to add a key (like \", _jsx(_components.code, {\n        children: \"code3\"\n      }), \") to our list of keys or its missing from our external data that we are using, we will be guaranteed that the return value is the correct shape and types.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhen trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:","excerptHTML":"<p>When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"When trying to be as type-safe as possible in Typescript, there are times when you may have to dynamically construct an object. You know as a programmer that all the keys will have values, but because you have to dynamically construct the values, the type system doesn’t know that the object is complete:\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["typescript"]}],"projects":[{"slug":"2023-08-07-wax-cpp-tutorial","date":"2023-08-07","title":"WAX C++ NFT Tutorial","frontmatter":{"title":"WAX C++ NFT Tutorial","image":"/images/project-wax.jpg","description":"WAX smart contract development course that guides developers through the process of creating a non-fungible token (NFT) smart contract.\n","language_tags":["node","cpp"],"framework_tags":["wax","blockchain","nfts"],"view_link":"https://dev.to/idmontie/series/23860","github_link":"https://github.com/CapsuleCat/wax-nft-tutorial"},"contentRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\n\nIt is a great introduction to WAX smart contract development and the WAX ecosystem.\n","contentHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.</p>\n<p>It is a great introduction to WAX smart contract development and the WAX ecosystem.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"This is a 22 part series on DevTo that goes through the entire process of creating\\na WAX Smart Contract that interacts with AtomicAssets and the WAX RNG Oracle.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is a great introduction to WAX smart contract development and the WAX ecosystem.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThis is a 22 part series on DevTo that goes through the entire process of creating","excerptHTML":"<p>This is a 22 part series on DevTo that goes through the entire process of creating</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"This is a 22 part series on DevTo that goes through the entire process of creating\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]},{"slug":"2023-08-04-lacework","date":"2023-08-04","title":"Lacework","frontmatter":{"title":"Lacework","image":"/images/project-lacework.png","description":"Cloud security monitoring at scale.\n","language_tags":["node","javascript","typescript","java"],"github_link":"https://github.com/lacework"},"contentRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\n","contentHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","contentCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nWhile at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.","excerptHTML":"<p>While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.</p>","excerptCode":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, props.components);\n  return _jsx(_components.p, {\n    children: \"While at Lacework, I worked on implementing entire new product lines for their cloud security offerings. This included architecting, implementing, and continuously delivering new features for Alerting, Identity Management, Resource Management, and Vulnerability Management on the web UI.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[]}]},"__N_SSG":true}