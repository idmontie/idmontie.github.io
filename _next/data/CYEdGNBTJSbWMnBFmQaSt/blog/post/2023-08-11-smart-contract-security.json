{"pageProps":{"headTitle":"Smart Contract Security - idmontie's Portfolio","headKeywords":"ethereum, smart-contracts, security","post":{"slug":"2023-08-11-smart-contract-security","date":"2023-08-11","title":"Smart Contract Security","frontmatter":{"title":"Smart Contract Security","tags":["ethereum","smart-contracts","security"]},"contentRaw":"\nThe crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\n\nIn general, the best practices around Smart Contracts are the same for writing secure code in general.\n\n## Keep it Simple\n\nKeep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.\n\n## Write Small Functions\n\nWrite small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.\n\n## Linting\n\nLint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.\n\n## Unit Tests\n\nUnit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called **negative** tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.\n\n## Scan for Security Vulnerabilities\n\nScan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.\n\nThere are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use [slither](https://github.com/crytic/slither):\n\n```tsx\nnpm install slither\nslither .\n```\n\nThis may take a while to run, but it will scan the compiles contracts for security issues.\n\n## Compliance\n\nFor Ethereum Smart Contracts, you can also use [slither](https://github.com/crytic/slither) to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.\n\n## Wrapping it Up\n\nSecurity is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.\n","contentHTML":"<p>The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.</p>\n<p>In general, the best practices around Smart Contracts are the same for writing secure code in general.</p>\n<h2>Keep it Simple</h2>\n<p>Keep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.</p>\n<h2>Write Small Functions</h2>\n<p>Write small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.</p>\n<h2>Linting</h2>\n<p>Lint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.</p>\n<h2>Unit Tests</h2>\n<p>Unit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called <strong>negative</strong> tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.</p>\n<h2>Scan for Security Vulnerabilities</h2>\n<p>Scan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.</p>\n<p>There are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use <a href=\"https://github.com/crytic/slither\">slither</a>:</p>\n<div class=\"overflow-auto rounded bg-gray-200 p-4 font-mono text-sm dark:bg-gray-800 dark:text-gray-100\"><pre><code class=\"language-tsx\">npm install slither\nslither .\n</code></pre></div>\n<p>This may take a while to run, but it will scan the compiles contracts for security issues.</p>\n<h2>Compliance</h2>\n<p>For Ethereum Smart Contracts, you can also use <a href=\"https://github.com/crytic/slither\">slither</a> to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.</p>\n<h2>Wrapping it Up</h2>\n<p>Security is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.</p>","contentCode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In general, the best practices around Smart Contracts are the same for writing secure code in general.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Keep it Simple\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Keep your Smart Contract code simple. Smart Contracts that try to be too clever often have unintended side-effects or functionality. Keeping a Smart Contract simple also means that the surface area for attacks is smaller.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Write Small Functions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Write small functions that do one thing. Many Smart Contracts will have many small functions that can be composed together, rather than one large function that does everything. This helps keep the code readable, making it easier to understand and secure.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Linting\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lint your code. Smart Contracts written in Solidity have tools already written that can help catch common errors via linting. The easiest linters to set up just help improve formatting, but some can help you write more secure code by letting your know when functions have been deprecated or marked as insecure.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Unit Tests\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Unit test your code. The best unit tests you can write for Smart Contracts are validating what users shouldn’t be able to do. As an example, make sure unauthorized accounts cannot withdraw assets from your contract. These are sometimes called \", _jsx(_components.strong, {\n        children: \"negative\"\n      }), \" tests and they can be even more important than your typical that validate your functions do what you expect them to do. These tests check that they fail in the correct way when misused.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Scan for Security Vulnerabilities\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Scan your code for security vulnerabilities. This is pretty self-explanatory. Many Smart Contract toolchains provide scanning tools to check your Smart Contract code.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are a few ways to surface security issues in Ethereum Smart Contracts. One way is to use \", _jsx(_components.a, {\n        href: \"https://github.com/crytic/slither\",\n        children: \"slither\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"npm install slither\\nslither .\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This may take a while to run, but it will scan the compiles contracts for security issues.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Compliance\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For Ethereum Smart Contracts, you can also use \", _jsx(_components.a, {\n        href: \"https://github.com/crytic/slither\",\n        children: \"slither\"\n      }), \" to check the compliance of your ERC20 token or ERC721 contracts. Running this check will verify that your contract implements the expected interfaces of the given contracts.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Wrapping it Up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Security is a major consideration in any application, but Smart Contracts pose a new type of attack vector for malicious users. Smart Contracts often interact with pools of cryptocurrency, NFTs, and other blockchain assets that make them new targets for attackers. It’s important when writing Smart Contracts to always make sure the contract fails correctly, even more-so than completing actions successfully.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerptRaw":"\nThe crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.","excerptHTML":"<p>The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.</p>","excerptCode":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"The crypto craze has died down, but if you are working on Smart Contracts or thinking about creating a new blockchain projects, security is a huge part of making sure the project is successful. Since Smart Contracts often interact with cryptocurrencies, blockchain assets, or other tokens, it’s important to make sure the Smart Contract is secure and follows best practices.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":["ethereum","smart-contracts","security"]},"previous":{"slug":"2023-08-12-ensuring-all-of-type","title":"Forbidden Typescript: ensuring all of a type"},"next":{"slug":"2023-08-10-get-class","title":"Forbidden Typescript: Get Class Name"}},"__N_SSG":true}